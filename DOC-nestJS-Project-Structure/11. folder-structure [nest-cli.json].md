**📂 test/ Directory — Purpose & Best Practices**

The test/ folder is the central place to organize all testing-related files. NestJS scaffolds this by default, but we enhance it for **structured, scalable** testing support.

-----
**✅ Recommended Folder Structure for test/**

test/

├── app.e2e-spec.ts              # Sample e2e test for app module

├── jest-e2e.json                # Jest config for E2E

├── unit/

│   ├── user.service.spec.ts     # Unit test example

│   └── auth.service.spec.ts     # Unit test example

├── integration/

│   └── user-auth.integration.spec.ts  # Auth integration test

├── mocks/

│   ├── user.mock.ts             # Sample mock user data

│   └── auth.mock.ts             # Sample mock auth token

└── utils/

`    `└── setup-test-app.ts        # Bootstrap Nest test app

-----
**🔍 Folder/Files Breakdown & Example**

**📁 unit/**

- **Purpose**: Isolated testing of services, utils, and classes without DB or external APIs.

**Example: user.service.spec.ts**

import { Test, TestingModule } from '@nestjs/testing';

import { UserService } from '../../src/modules/user/user.service';

describe('UserService', () => {

`  `let service: UserService;

`  `beforeEach(async () => {

`    `const module: TestingModule = await Test.createTestingModule({

`      `providers: [UserService],

`    `}).compile();

`    `service = module.get<UserService>(UserService);

`  `});

`  `it('should be defined', () => {

`    `expect(service).toBeDefined();

`  `});

`  `it('should return user', async () => {

`    `const result = await service.getUserById(1);

`    `expect(result).toBeTruthy();

`  `});

});

-----
**📁 integration/**

- **Purpose**: Tests combining multiple services/modules with real logic (may include test DB).

**Example: user-auth.integration.spec.ts**

import \* as request from 'supertest';

import { INestApplication } from '@nestjs/common';

import { Test } from '@nestjs/testing';

import { AppModule } from '../../src/app.module';

describe('AuthController (integration)', () => {

`  `let app: INestApplication;

`  `beforeAll(async () => {

`    `const moduleFixture = await Test.createTestingModule({

`      `imports: [AppModule],

`    `}).compile();

`    `app = moduleFixture.createNestApplication();

`    `await app.init();

`  `});

`  `it('/auth/login (POST)', async () => {

`    `return request(app.getHttpServer())

.post('/auth/login')

.send({ email: 'admin@example.com', password: 'admin' })

.expect(201);

`  `});

`  `afterAll(async () => {

`    `await app.close();

`  `});

});

-----
**📁 mocks/**

- **Purpose**: Store mock objects/functions/stubs for reuse in tests.

**Example: user.mock.ts**

export const mockUser = {

`  `id: 1,

`  `email: 'admin@example.com',

`  `password: 'hashedPassword',

};

-----
**📁 utils/**

- **Purpose**: Bootstrap or teardown logic for testing

**Example: setup-test-app.ts**

import { Test } from '@nestjs/testing';

import { AppModule } from '../../src/app.module';

import { INestApplication } from '@nestjs/common';

export async function createTestApp(): Promise<INestApplication> {

`  `const moduleRef = await Test.createTestingModule({

`    `imports: [AppModule],

`  `}).compile();

`  `const app = moduleRef.createNestApplication();

`  `await app.init();

`  `return app;

}

-----
**📄 app.e2e-spec.ts**

- NestJS scaffolded E2E test
- Can be replaced by your own grouped tests in integration/
-----
**📄 jest-e2e.json**

**Sample jest-e2e.json:**

{

`  `"moduleFileExtensions": ["js", "json", "ts"],

`  `"rootDir": "../",

`  `"testRegex": ".e2e-spec.ts$",

`  `"transform": {

`    `"^.+\\.(t|j)s$": "ts-jest"

`  `},

`  `"setupFiles": ["dotenv/config"],

`  `"testEnvironment": "node"

}

-----
**🧪 Run Your Tests**

**Run all tests:**

npm run test

**Run only unit tests:**

npm run test:unit

**Run only integration/e2e:**

npm run test:e2e

You can configure these in package.json like:

"scripts": {

`  `"test": "jest",

`  `"test:unit": "jest --config test/jest-unit.json",

`  `"test:e2e": "jest --config test/jest-e2e.json"

}

-----
**🛡 Best Practices for Production Testing**

|**🟢 Best Practice**|**✅ Benefit**|
| :-: | :-: |
|Use test DB for integration|Prevent production data mutation|
|Separate test config (.env.test)|Isolate environments|
|Use mocking where possible|Speed + isolation|
|Automate in CI (GitHub Actions)|Reliable pre-deployment checks|
|Use coverage reports|Track quality and gaps|

-----
