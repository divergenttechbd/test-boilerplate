**📦 Environment Config Files in NestJS**

These .env files store environment-specific values like:

- Database credentials
- API keys
- Port, host, domain
- Feature flags (enable/disable features)
-----
**📁 Folder/File Structure**

root/

├── .env                   # Default fallback env

├── .env.development       # For development-specific values

├── .env.production        # For production deployment

├── .env.test              # For unit/integration test env

├── src/

│   └── config/

│       └── configuration.ts   # Central config loader (type-safe)

│       └── validation.ts      # Joi schema validation

-----
**🔧 Step 1: Create .env Files**

**✅ .env (Fallback / shared values)**

APP_NAME=MyNestApp

PORT=3000

NODE_ENV=development

-----
**✅ .env.development**

NODE_ENV=development

DB_HOST=localhost

DB_PORT=5432

DB_USERNAME=dev_user

DB_PASSWORD=dev_pass

DB_NAME=dev_db

REDIS_HOST=localhost

REDIS_PORT=6379

-----
**✅ .env.production**

NODE_ENV=production

DB_HOST=

DB_PORT=

DB_USERNAME=

DB_PASSWORD=

DB_NAME=prod_db

REDIS_HOST=prod-redis-host

REDIS_PORT=6379

-----
**✅ .env.test**

NODE_ENV=test

DB_HOST=localhost

DB_PORT=5432

DB_USERNAME=

DB_PASSWORD=

DB_NAME=test_db

-----
**🔧 Step 2: Configure NestJS to Load .env**

Install dependencies:

npm i @nestjs/config joi

-----
**✅ src/config/configuration.ts**

// src/config/configuration.ts

export default () => ({

`  `appName: process.env.APP_NAME,

`  `port: parseInt(process.env.PORT, 10) || 3000,

`  `nodeEnv: process.env.NODE_ENV,

`  `database: {

`    `host: process.env.DB_HOST,

`    `port: parseInt(process.env.DB_PORT, 10),

`    `username: process.env.DB_USERNAME,

`    `password: process.env.DB_PASSWORD,

`    `name: process.env.DB_NAME,

`  `},

`  `redis: {

`    `host: process.env.REDIS_HOST,

`    `port: parseInt(process.env.REDIS_PORT, 10),

`  `},

});

-----
**✅ src/config/validation.ts**

// src/config/validation.ts

import \* as Joi from 'joi';

export const validationSchema = Joi.object({

`  `APP_NAME: Joi.string().default('MyNestApp'),

`  `PORT: Joi.number().default(3000),

`  `NODE_ENV: Joi.string().valid('development', 'production', 'test').required(),

`  `DB_HOST: Joi.string().required(),

`  `DB_PORT: Joi.number().default(5432),

`  `DB_USERNAME: Joi.string().required(),

`  `DB_PASSWORD: Joi.string().required(),

`  `DB_NAME: Joi.string().required(),

`  `REDIS_HOST: Joi.string().required(),

`  `REDIS_PORT: Joi.number().default(6379),

});

-----
**🧩 Step 3: Import in AppModule**

// src/app.module.ts

import { Module } from '@nestjs/common';

import { ConfigModule } from '@nestjs/config';

import configuration from './config/configuration';

import { validationSchema } from './config/validation';

@Module({

`  `imports: [

`    `ConfigModule.forRoot({

`      `isGlobal: true,

`      `envFilePath: [`.env.${process.env.NODE_ENV}`, '.env'],

`      `load: [configuration],

`      `validationSchema,

`    `}),

`  `],

})

export class AppModule {}

-----
**🎯 Step 4: Use Config in Your Services**

// Example: src/app.service.ts

import { Injectable } from '@nestjs/common';

import { ConfigService } from '@nestjs/config';

@Injectable()

export class AppService {

`  `constructor(private config: ConfigService) {}

`  `getDatabaseHost(): string {

`    `return this.config.get<string>('database.host');

`  `}

`  `getPort(): number {

`    `return this.config.get<number>('port');

`  `}

}

-----
**✅ Best Practices Summary**

|**🔧 Practice**|**✅ Description**|
| :-: | :-: |
|.env.\* per environment|Keeps secrets and values separate|
|validation.ts|Prevents runtime failures from bad/missing values|
|ConfigModule.forRoot()|Enables global, validated, and layered env loading|
|Typed access via ConfigService|Avoids typo errors and improves maintainability|
|Don’t commit .env\*|Always add .env\* to .gitignore|
|Use .env.production with Docker/K8s|Match file with deployment strategy|

-----

