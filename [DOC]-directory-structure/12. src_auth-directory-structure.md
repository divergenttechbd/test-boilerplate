Absolutely! Let's now move into one of the most critical parts of any backend system ‚Äî the `auth/` directory. We will break it down **step by step**, explain **each file's purpose**, and provide **full code with detailed line-by-line comments**.

---

# üîê `auth/` Directory ‚Äì Overview

The `auth/` module handles:

- User login and signup
- JWT authentication
- Password hashing & validation
- Role or permission-based access control
- Guards & strategies
- Integration with `Passport.js`

---

## üßæ Directory Structure

```
üìÅ auth/
‚îÇ
‚îú‚îÄ‚îÄ üìÑ auth.module.ts           # Registers providers (guards, strategies, services)
‚îú‚îÄ‚îÄ üìÑ auth.service.ts          # Core logic: login, validate user, generate JWT
‚îú‚îÄ‚îÄ üìÑ auth.controller.ts       # Login route, token issuance
‚îÇ
‚îú‚îÄ‚îÄ üõ°Ô∏è guards/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ jwt-auth.guard.ts     # Protects endpoints using JWT
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ roles.guard.ts        # Optional: restrict access based on role
‚îÇ
‚îú‚îÄ‚îÄ üß† strategies/
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ jwt.strategy.ts       # How JWT is validated (extends Passport strategy)
‚îÇ
‚îú‚îÄ‚îÄ üß¨ dto/
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ login.dto.ts          # Login input validation
‚îÇ
‚îî‚îÄ‚îÄ üîê interfaces/
    ‚îî‚îÄ‚îÄ üìÑ auth-payload.interface.ts  # Payload interface used across strategy & guards
```

---

# üìÑ `auth.module.ts`

### ‚úÖ Purpose

Initializes the whole auth module. Registers service, controller, guards, and strategy.

```ts
import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './strategies/jwt.strategy';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { RolesGuard } from './guards/roles.guard';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    PassportModule, // Enables use of Passport strategies
    JwtModule.registerAsync({
      imports: [ConfigModule], // Inject config service
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'), // From env config
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN') || '1h',
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    JwtStrategy,
    JwtAuthGuard,
    RolesGuard, // optional, for RBAC
  ],
  exports: [AuthService], // Export if other modules need auth logic
})
export class AuthModule {}
```

---

# üìÑ `auth.service.ts`

### ‚úÖ Purpose

Handles:

- Validating user credentials
- Generating JWT tokens
- Hashing and comparing passwords

```ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
  constructor(private readonly jwtService: JwtService) {}

  // Simulate user validation from DB
  async validateUser(email: string, pass: string): Promise<any> {
    // You would normally fetch this from DB
    const user = { id: 1, email: 'test@example.com', password: '$2b$10$123hashed' };

    const isMatch = await bcrypt.compare(pass, user.password);
    if (!isMatch) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Exclude password from return
    const { password, ...result } = user;
    return result;
  }

  // Generate JWT token
  async login(user: any) {
    const payload = { sub: user.id, email: user.email };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }

  // Optional: Hash password (e.g., for signup)
  async hashPassword(plainPassword: string): Promise<string> {
    const saltRounds = 10;
    return await bcrypt.hash(plainPassword, saltRounds);
  }
}
```

---

# üìÑ `auth.controller.ts`

### ‚úÖ Purpose

Defines the `/auth/login` endpoint

```ts
import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  // Route: POST /auth/login
  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    const user = await this.authService.validateUser(loginDto.email, loginDto.password);
    return this.authService.login(user);
  }
}
```

---

# üìÑ `dto/login.dto.ts`

### ‚úÖ Purpose

Defines shape and validation rules for login request body

```ts
import { IsEmail, IsNotEmpty } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  password: string;
}
```

---

# üìÑ `interfaces/auth-payload.interface.ts`

### ‚úÖ Purpose

Shared payload used in guards, strategies

```ts
export interface AuthPayload {
  sub: number;       // user ID
  email: string;
  iat?: number;       // issued at (automatically added by JWT)
  exp?: number;       // expiration time
}
```

---

# üìÑ `guards/jwt-auth.guard.ts`

### ‚úÖ Purpose

Protect routes using JWT token

```ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
// Uses Passport JWT strategy behind the scenes
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

---

# üìÑ `guards/roles.guard.ts` (Optional for RBAC)

```ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.get<string[]>('roles', context.getHandler());
    if (!requiredRoles || requiredRoles.length === 0) return true;

    const user = context.switchToHttp().getRequest().user;
    if (!requiredRoles.includes(user.role)) {
      throw new ForbiddenException('Insufficient permissions');
    }
    return true;
  }
}
```

To use this, decorate your route like:

```ts
@Roles('admin')
@UseGuards(JwtAuthGuard, RolesGuard)
@Get('admin-data')
```

---

# üìÑ `strategies/jwt.strategy.ts`

### ‚úÖ Purpose

Defines how JWT is parsed and validated

```ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { AuthPayload } from '../interfaces/auth-payload.interface';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_SECRET'),
    });
  }

  // Called on every authenticated request
  async validate(payload: AuthPayload) {
    // You could also fetch full user from DB here
    return payload;
  }
}
```

---

## üõ†Ô∏è Configuration: `.env`

```
JWT_SECRET=mySuperSecretKey
JWT_EXPIRES_IN=1h
```

---

# üîê Summary of Key Concepts

| Feature | Description |
|--------|-------------|
| `AuthService` | Core logic: login, token issue, password check |
| `JwtStrategy` | Defines how to validate the token |
| `JwtAuthGuard` | Protects routes that need auth |
| `RolesGuard` | Optional role-based route control |
| `LoginDto` | Validates incoming login request |
| `auth.controller` | Handles login endpoint |

---
---

## ‚úÖ Objectives Recap

You requested:

- **Refresh token flow** implementation.
- **Social login** integration for Google, Facebook, LinkedIn, Twitter.
- **Two-factor authentication (2FA)** via:
  - Email
  - SMS
  - WhatsApp
- **Every code file and line with detailed inline comments** and **clear use-case explanation**.

---

## üß© Let‚Äôs Start with: Refresh Token Flow

We‚Äôll break it down into the following parts:

```bash
auth/
‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îî‚îÄ‚îÄ jwt-auth.guard.ts        # Protects endpoints with access token
‚îÇ   ‚îî‚îÄ‚îÄ refresh-token.guard.ts   # Verifies refresh token
‚îú‚îÄ‚îÄ strategies/
‚îÇ   ‚îî‚îÄ‚îÄ jwt.strategy.ts          # Handles JWT access strategy
‚îÇ   ‚îî‚îÄ‚îÄ refresh.strategy.ts      # Handles refresh token strategy
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ auth.service.ts          # Core auth logic (login, signup, token issue)
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îî‚îÄ‚îÄ auth.controller.ts       # API endpoints
‚îú‚îÄ‚îÄ dtos/
‚îÇ   ‚îî‚îÄ‚îÄ login.dto.ts
‚îÇ   ‚îî‚îÄ‚îÄ refresh-token.dto.ts
‚îú‚îÄ‚îÄ auth.module.ts               # Binds everything
```

---

### 1Ô∏è‚É£ `auth.controller.ts` ‚Äì Auth API Endpoints

```ts
// src/auth/controllers/auth.controller.ts

import {
  Controller,
  Post,
  Body,
  UseGuards,
  Req,
} from '@nestjs/common';
import { AuthService } from '../services/auth.service';
import { LoginDto } from '../dtos/login.dto';
import { RefreshTokenDto } from '../dtos/refresh-token.dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  /**
   * POST /auth/login
   * Authenticates user and returns access + refresh token
   */
  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  /**
   * POST /auth/refresh-token
   * Uses a valid refresh token to issue a new access token
   */
  @Post('refresh-token')
  async refreshToken(@Body() refreshDto: RefreshTokenDto) {
    return this.authService.refreshAccessToken(refreshDto);
  }
}
```

---

### 2Ô∏è‚É£ `auth.service.ts` ‚Äì Handles token generation & refresh

```ts
// src/auth/services/auth.service.ts

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { LoginDto } from '../dtos/login.dto';
import { RefreshTokenDto } from '../dtos/refresh-token.dto';

@Injectable()
export class AuthService {
  constructor(private jwtService: JwtService) {}

  /**
   * Login user and issue JWT tokens (access + refresh)
   */
  async login(loginDto: LoginDto) {
    const user = await this.validateUser(loginDto); // your own logic here

    const payload = { sub: user.id, email: user.email };
    const accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });
    const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });

    return {
      user,
      tokens: { accessToken, refreshToken },
    };
  }

  /**
   * Re-issue access token using a valid refresh token
   */
  async refreshAccessToken(refreshDto: RefreshTokenDto) {
    try {
      const payload = this.jwtService.verify(refreshDto.refreshToken);
      const newAccessToken = this.jwtService.sign(
        { sub: payload.sub, email: payload.email },
        { expiresIn: '15m' },
      );
      return { accessToken: newAccessToken };
    } catch (error) {
      throw new UnauthorizedException('Invalid refresh token');
    }
  }

  /**
   * Custom user validation logic
   */
  private async validateUser(loginDto: LoginDto) {
    // TODO: Replace with your actual DB/service check
    if (loginDto.email === 'admin@example.com' && loginDto.password === 'admin') {
      return { id: 1, email: loginDto.email };
    }
    throw new UnauthorizedException('Invalid credentials');
  }
}
```

---

### 3Ô∏è‚É£ `refresh-token.guard.ts` ‚Äì Optional Guard (if needed for route protection)

```ts
// src/auth/guards/refresh-token.guard.ts

import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class RefreshTokenGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = request.body.refreshToken;
    if (!token) throw new UnauthorizedException('Refresh token missing');

    try {
      request.user = this.jwtService.verify(token);
      return true;
    } catch {
      throw new UnauthorizedException('Invalid refresh token');
    }
  }
}
```

---

### 4Ô∏è‚É£ `refresh-token.dto.ts` ‚Äì DTO for Refresh Flow

```ts
// src/auth/dtos/refresh-token.dto.ts

import { IsString } from 'class-validator';

export class RefreshTokenDto {
  @IsString()
  refreshToken: string;
}
```

---

## üîê What‚Äôs Next?

In the next reply, I will **move to**:

### ‚úÖ Social Login Implementation

- Google, Facebook, LinkedIn, Twitter
- Includes:
  - `passport` strategies
  - Redirect handlers
  - User entity population

---

Perfect ‚Äî let‚Äôs now **dive deep into the Refresh Token Flow**.

---

## ‚úÖ Full Implementation of Refresh Token Flow in NestJS

This implementation ensures:

- Secure issuance of **access & refresh tokens** during login.
- Storing **refresh tokens** securely in DB for validation.
- **Token revocation** (logout / invalidation).
- Use of **guards** & **strategies** for token validation.
- Detailed **code comments and real-world best practices**.

---

### ‚úÖ Why Use a Refresh Token?

1. **Access tokens are short-lived** (e.g., 15 minutes).
2. Refresh tokens **allow re-issuing** new access tokens without re-login.
3. Enhances **security** (access tokens are rarely reused).
4. Protects against session hijacking.

---

## üóÇ Directory Structure (`auth/`)

```
auth/
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îî‚îÄ‚îÄ auth.controller.ts         # Handles login, refresh, logout
‚îú‚îÄ‚îÄ dtos/
‚îÇ   ‚îú‚îÄ‚îÄ login.dto.ts               # DTO for login
‚îÇ   ‚îî‚îÄ‚îÄ refresh-token.dto.ts       # DTO for refresh token
‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îî‚îÄ‚îÄ refresh-token.entity.ts    # DB model for storing refresh tokens
‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îî‚îÄ‚îÄ jwt-auth.guard.ts          # Guard for access token
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ auth.service.ts            # Auth business logic
‚îú‚îÄ‚îÄ strategies/
‚îÇ   ‚îî‚îÄ‚îÄ jwt.strategy.ts            # JWT strategy for access
‚îÇ   ‚îî‚îÄ‚îÄ refresh.strategy.ts        # Strategy for refresh token
‚îî‚îÄ‚îÄ auth.module.ts                 # Registers services and strategies
```

---

### 1Ô∏è‚É£ `auth.controller.ts`

```ts
// src/auth/controllers/auth.controller.ts

import {
  Controller,
  Post,
  Body,
  Req,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { AuthService } from '../services/auth.service';
import { LoginDto } from '../dtos/login.dto';
import { RefreshTokenDto } from '../dtos/refresh-token.dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  /**
   * Login endpoint - returns access & refresh token
   */
  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  /**
   * Refresh token endpoint - reissues access token
   */
  @Post('refresh')
  @HttpCode(HttpStatus.OK)
  async refresh(@Body() refreshTokenDto: RefreshTokenDto) {
    return this.authService.refreshToken(refreshTokenDto);
  }

  /**
   * Logout - invalidate refresh token
   */
  @Post('logout')
  async logout(@Body() refreshTokenDto: RefreshTokenDto) {
    return this.authService.logout(refreshTokenDto.refreshToken);
  }
}
```

---

### 2Ô∏è‚É£ `auth.service.ts`

```ts
// src/auth/services/auth.service.ts

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { LoginDto } from '../dtos/login.dto';
import { RefreshTokenDto } from '../dtos/refresh-token.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { RefreshToken } from '../entities/refresh-token.entity';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private readonly jwtService: JwtService,
    @InjectRepository(RefreshToken)
    private readonly refreshTokenRepo: Repository<RefreshToken>,
  ) {}

  /**
   * Authenticates user, issues tokens, stores hashed refresh token
   */
  async login(loginDto: LoginDto) {
    // TODO: Replace with real user validation
    const user = { id: 1, email: loginDto.email };

    const payload = { sub: user.id, email: user.email };
    const accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });
    const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });

    // Store refresh token (hashed)
    const hashedToken = await bcrypt.hash(refreshToken, 10);
    await this.refreshTokenRepo.save({
      userId: user.id,
      token: hashedToken,
    });

    return { user, accessToken, refreshToken };
  }

  /**
   * Validates refresh token, reissues new access token
   */
  async refreshToken(refreshDto: RefreshTokenDto) {
    const payload = this.jwtService.verify(refreshDto.refreshToken);

    const savedToken = await this.refreshTokenRepo.findOneBy({
      userId: payload.sub,
    });

    if (!savedToken)
      throw new UnauthorizedException('No refresh token found for user');

    const match = await bcrypt.compare(refreshDto.refreshToken, savedToken.token);
    if (!match) throw new UnauthorizedException('Invalid refresh token');

    const newAccessToken = this.jwtService.sign(
      { sub: payload.sub, email: payload.email },
      { expiresIn: '15m' },
    );

    return { accessToken: newAccessToken };
  }

  /**
   * Revokes refresh token (logout)
   */
  async logout(refreshToken: string) {
    try {
      const payload = this.jwtService.verify(refreshToken);
      await this.refreshTokenRepo.delete({ userId: payload.sub });
    } catch {
      throw new UnauthorizedException('Invalid token');
    }
    return { message: 'Logged out successfully' };
  }
}
```

---

### 3Ô∏è‚É£ `refresh-token.entity.ts`

```ts
// src/auth/entities/refresh-token.entity.ts

import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';

/**
 * Stores hashed refresh token per user
 */
@Entity('refresh_tokens')
export class RefreshToken {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  userId: number;

  @Column()
  token: string;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  createdAt: Date;
}
```

---

### 4Ô∏è‚É£ `refresh-token.dto.ts`

```ts
// src/auth/dtos/refresh-token.dto.ts

import { IsString } from 'class-validator';

export class RefreshTokenDto {
  @IsString()
  refreshToken: string;
}
```

---

### 5Ô∏è‚É£ `auth.module.ts`

```ts
// src/auth/auth.module.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './services/auth.service';
import { AuthController } from './controllers/auth.controller';
import { RefreshToken } from './entities/refresh-token.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([RefreshToken]),
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'mysecret',
    }),
  ],
  providers: [AuthService],
  controllers: [AuthController],
})
export class AuthModule {}
```

---

## üîê Security Best Practices

- Store **only hashed** refresh tokens.
- Optionally tie tokens to **device/fingerprint/IP**.
- Use **secure HttpOnly cookies** for refresh tokens in production.
- Rotate refresh token with every use.
- Implement **refresh token reuse detection** (advanced).

---

## ‚úÖ What‚Äôs Next?

continue with:

1. **Social login integrations** (Google, Facebook, etc.)
2. **2FA (Two-Factor Authentication)** via Email, SMS, WhatsApp

---

Let's continue with **Social Login Integrations** for platforms like Google, Facebook, LinkedIn, and Twitter.

### Overview

In social login, a user logs into your application via their credentials from social media platforms. This typically simplifies the process for the user while ensuring you have a secure means of authentication using OAuth or OpenID Connect protocols.

We'll be covering:

1. **Social login using Passport.js** for OAuth strategies.
2. **Configuration for Google, Facebook, LinkedIn, and Twitter**.
3. **Detailed code comments** for each integration.

### üìÇ Social Login Directory Structure

```
auth/
‚îú‚îÄ‚îÄ strategies/
‚îÇ   ‚îú‚îÄ‚îÄ google.strategy.ts           # Google OAuth strategy
‚îÇ   ‚îú‚îÄ‚îÄ facebook.strategy.ts         # Facebook OAuth strategy
‚îÇ   ‚îú‚îÄ‚îÄ linkedin.strategy.ts         # LinkedIn OAuth strategy
‚îÇ   ‚îî‚îÄ‚îÄ twitter.strategy.ts          # Twitter OAuth strategy
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îî‚îÄ‚îÄ social-login.controller.ts   # Handle social login redirect and callback
‚îú‚îÄ‚îÄ auth.module.ts                   # Register the social strategies and controller
```

---

### 1Ô∏è‚É£ **Installation of Required Packages**

You‚Äôll need to install the necessary packages for OAuth and Passport strategies.

```bash
npm install @nestjs/passport passport passport-google-oauth20 passport-facebook passport-linkedin-oauth2 passport-twitter
```

Additionally, we will need to install `@nestjs/passport` and `passport` which will enable handling social authentication:

```bash
npm install @nestjs/passport passport
```

---

### 2Ô∏è‚É£ **Google OAuth Strategy** (`google.strategy.ts`)

```ts
// src/auth/strategies/google.strategy.ts

import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-google-oauth20';
import { AuthService } from '../services/auth.service';
import { Profile } from 'passport-google-oauth20';

// This strategy handles Google login using OAuth 2.0.
@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor(private readonly authService: AuthService) {
    super({
      clientID: process.env.GOOGLE_CLIENT_ID, // Provided by Google
      clientSecret: process.env.GOOGLE_CLIENT_SECRET, // Provided by Google
      callbackURL: process.env.GOOGLE_CALLBACK_URL, // Redirect URL
      scope: ['email', 'profile'],
    });
  }

  /**
   * Handles the callback from Google after user authentication.
   * @param accessToken - Access token to make API calls to Google.
   * @param refreshToken - Refresh token for refreshing the session.
   * @param profile - The profile of the authenticated user.
   * @param done - Passport callback to signal that the authentication is complete.
   */
  async validate(accessToken: string, refreshToken: string, profile: Profile) {
    const user = await this.authService.validateOAuthLogin(profile);
    return user;  // This user will be attached to the request object.
  }
}
```

---

### 3Ô∏è‚É£ **Facebook OAuth Strategy** (`facebook.strategy.ts`)

```ts
// src/auth/strategies/facebook.strategy.ts

import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-facebook';
import { AuthService } from '../services/auth.service';
import { Profile } from 'passport-facebook';

@Injectable()
export class FacebookStrategy extends PassportStrategy(Strategy, 'facebook') {
  constructor(private readonly authService: AuthService) {
    super({
      clientID: process.env.FACEBOOK_APP_ID,
      clientSecret: process.env.FACEBOOK_APP_SECRET,
      callbackURL: process.env.FACEBOOK_CALLBACK_URL,
      scope: ['email'],
    });
  }

  /**
   * Handles the callback from Facebook after user authentication.
   * @param accessToken - Access token to make API calls to Facebook.
   * @param refreshToken - Refresh token for refreshing the session.
   * @param profile - The profile of the authenticated user.
   * @param done - Passport callback to signal that the authentication is complete.
   */
  async validate(accessToken: string, refreshToken: string, profile: Profile) {
    const user = await this.authService.validateOAuthLogin(profile);
    return user;
  }
}
```

---

### 4Ô∏è‚É£ **LinkedIn OAuth Strategy** (`linkedin.strategy.ts`)

```ts
// src/auth/strategies/linkedin.strategy.ts

import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-linkedin-oauth2';
import { AuthService } from '../services/auth.service';
import { Profile } from 'passport-linkedin-oauth2';

@Injectable()
export class LinkedInStrategy extends PassportStrategy(Strategy, 'linkedin') {
  constructor(private readonly authService: AuthService) {
    super({
      clientID: process.env.LINKEDIN_CLIENT_ID,
      clientSecret: process.env.LINKEDIN_CLIENT_SECRET,
      callbackURL: process.env.LINKEDIN_CALLBACK_URL,
      scope: ['r_emailaddress', 'r_liteprofile'],
    });
  }

  /**
   * Handles the callback from LinkedIn after user authentication.
   * @param accessToken - Access token to make API calls to LinkedIn.
   * @param refreshToken - Refresh token for refreshing the session.
   * @param profile - The profile of the authenticated user.
   * @param done - Passport callback to signal that the authentication is complete.
   */
  async validate(accessToken: string, refreshToken: string, profile: Profile) {
    const user = await this.authService.validateOAuthLogin(profile);
    return user;
  }
}
```

---

### 5Ô∏è‚É£ **Twitter OAuth Strategy** (`twitter.strategy.ts`)

```ts
// src/auth/strategies/twitter.strategy.ts

import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-twitter';
import { AuthService } from '../services/auth.service';
import { Profile } from 'passport-twitter';

@Injectable()
export class TwitterStrategy extends PassportStrategy(Strategy, 'twitter') {
  constructor(private readonly authService: AuthService) {
    super({
      consumerKey: process.env.TWITTER_CONSUMER_KEY,
      consumerSecret: process.env.TWITTER_CONSUMER_SECRET,
      callbackURL: process.env.TWITTER_CALLBACK_URL,
    });
  }

  /**
   * Handles the callback from Twitter after user authentication.
   * @param token - Access token to make API calls to Twitter.
   * @param tokenSecret - Secret for the access token.
   * @param profile - The profile of the authenticated user.
   * @param done - Passport callback to signal that the authentication is complete.
   */
  async validate(token: string, tokenSecret: string, profile: Profile) {
    const user = await this.authService.validateOAuthLogin(profile);
    return user;
  }
}
```

---

### 6Ô∏è‚É£ **Social Login Controller** (`social-login.controller.ts`)

```ts
// src/auth/controllers/social-login.controller.ts

import { Controller, Get, Req, UseGuards, Query } from '@nestjs/common';
import { AuthService } from '../services/auth.service';
import { AuthGuard } from '@nestjs/passport';

@Controller('auth/social')
export class SocialLoginController {
  constructor(private readonly authService: AuthService) {}

  /**
   * Google login redirect endpoint.
   * Redirects to Google OAuth login page.
   */
  @Get('google')
  @UseGuards(AuthGuard('google'))  // Triggers Google OAuth flow
  async googleLogin() {}

  /**
   * Google callback endpoint.
   * Handles the response after Google OAuth login.
   */
  @Get('google/callback')
  @UseGuards(AuthGuard('google'))
  googleLoginRedirect(@Req() req) {
    return this.authService.socialLoginRedirect(req.user);
  }

  /**
   * Facebook login redirect endpoint.
   * Redirects to Facebook OAuth login page.
   */
  @Get('facebook')
  @UseGuards(AuthGuard('facebook'))  // Triggers Facebook OAuth flow
  async facebookLogin() {}

  /**
   * Facebook callback endpoint.
   * Handles the response after Facebook OAuth login.
   */
  @Get('facebook/callback')
  @UseGuards(AuthGuard('facebook'))
  facebookLoginRedirect(@Req() req) {
    return this.authService.socialLoginRedirect(req.user);
  }
  
  // Add similar methods for LinkedIn and Twitter as needed...
}
```

---

### 7Ô∏è‚É£ **Auth Service: Validate Social Login** (`auth.service.ts`)

```ts
// src/auth/services/auth.service.ts

@Injectable()
export class AuthService {
  constructor(
    private readonly jwtService: JwtService,
    @InjectRepository(RefreshToken)
    private readonly refreshTokenRepo: Repository<RefreshToken>,
  ) {}

  /**
   * This method is invoked after a successful social login.
   * It validates the user from the social profile.
   */
  async validateOAuthLogin(profile: any) {
    // Check if user already exists or register them
    const user = await this.findOrCreateUser(profile);
    
    // Create JWT tokens (access token and refresh token)
    const payload = { sub: user.id, email: user.email };
    const accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });
    const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });

    // Store refresh token securely
    await this.storeRefreshToken(user.id, refreshToken);

    return { accessToken, refreshToken, user };
  }

  /**
   * Handle redirect after social login (return tokens)
   */
  async socialLoginRedirect(user: any) {
    return {
      message: 'Login successful',
      user,
    };
  }
}
```

---

### ‚úÖ Next Steps

You now have the full flow for **social logins** (Google, Facebook, LinkedIn, Twitter). You can:

1. Configure OAuth credentials for each provider in `.env` files.
2. Test login, handle the callback, and create or update user profiles.

---

### Step 1: **Configure OAuth Credentials for Each Provider in `.env` Files**

To make the social login work, you'll need to register your app with each provider (Google, Facebook, LinkedIn, Twitter) and obtain the credentials (client IDs, client secrets) for OAuth.

#### Add the following to your `.env` file

```env
# Google OAuth Configuration
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GOOGLE_CALLBACK_URL=http://localhost:3000/auth/social/google/callback

# Facebook OAuth Configuration
FACEBOOK_APP_ID=your-facebook-app-id
FACEBOOK_APP_SECRET=your-facebook-app-secret
FACEBOOK_CALLBACK_URL=http://localhost:3000/auth/social/facebook/callback

# LinkedIn OAuth Configuration
LINKEDIN_CLIENT_ID=your-linkedin-client-id
LINKEDIN_CLIENT_SECRET=your-linkedin-client-secret
LINKEDIN_CALLBACK_URL=http://localhost:3000/auth/social/linkedin/callback

# Twitter OAuth Configuration
TWITTER_CONSUMER_KEY=your-twitter-consumer-key
TWITTER_CONSUMER_SECRET=your-twitter-consumer-secret
TWITTER_CALLBACK_URL=http://localhost:3000/auth/social/twitter/callback
```

### Step 2: **Test Login, Handle the Callback, and Create or Update User Profiles**

#### 1. **Social Login Flow (Frontend/Client)**

The frontend will need to trigger the social login by redirecting users to the appropriate provider (Google, Facebook, etc.).

Here‚Äôs an example flow:

- **Redirect User** to the appropriate social login page (Google, Facebook, etc.).
- Once the user authenticates, **redirect them back** to the callback URL configured in `.env` (e.g., `google/callback`).

On the frontend, you could use something like this to trigger the login:

```html
<!-- Example Button to Trigger Social Login -->
<a href="/auth/social/google">Login with Google</a>
<a href="/auth/social/facebook">Login with Facebook</a>
<a href="/auth/social/linkedin">Login with LinkedIn</a>
<a href="/auth/social/twitter">Login with Twitter</a>
```

#### 2. **Callback and Profile Creation/Update (Backend)**

Once the user is redirected back to the server after authentication, the Passport strategies will validate and process the user's profile.

The controller will handle the callback and create or update the user profile.

**Example in `social-login.controller.ts`:**

```ts
// src/auth/controllers/social-login.controller.ts

@Controller('auth/social')
export class SocialLoginController {
  constructor(private readonly authService: AuthService) {}

  // Google login callback
  @Get('google/callback')
  @UseGuards(AuthGuard('google'))  // Google OAuth Guard
  async googleLoginRedirect(@Req() req) {
    return this.authService.socialLoginRedirect(req.user);  // Handle the user profile and JWT
  }

  // Facebook login callback
  @Get('facebook/callback')
  @UseGuards(AuthGuard('facebook'))  // Facebook OAuth Guard
  async facebookLoginRedirect(@Req() req) {
    return this.authService.socialLoginRedirect(req.user);  // Handle the user profile and JWT
  }

  // LinkedIn login callback
  @Get('linkedin/callback')
  @UseGuards(AuthGuard('linkedin'))  // LinkedIn OAuth Guard
  async linkedinLoginRedirect(@Req() req) {
    return this.authService.socialLoginRedirect(req.user);  // Handle the user profile and JWT
  }

  // Twitter login callback
  @Get('twitter/callback')
  @UseGuards(AuthGuard('twitter'))  // Twitter OAuth Guard
  async twitterLoginRedirect(@Req() req) {
    return this.authService.socialLoginRedirect(req.user);  // Handle the user profile and JWT
  }
}
```

In this controller:

- The `AuthGuard('google')` (or the appropriate social login strategy) ensures that the user is authenticated via OAuth.
- The `req.user` object contains the user profile returned by the respective OAuth strategy, which will then be handled by `socialLoginRedirect()` to either create a new user or update an existing one in your system.

#### 3. **Creating/Updating the User Profile (AuthService)**

Here‚Äôs how the user is validated, created, or updated in the database:

**Example in `auth.service.ts`:**

```ts
// src/auth/services/auth.service.ts

@Injectable()
export class AuthService {
  constructor(
    private readonly jwtService: JwtService,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  /**
   * This method is invoked after a successful social login.
   * It validates the user from the social profile.
   */
  async validateOAuthLogin(profile: any) {
    // Look for an existing user in the database with the given social ID
    let user = await this.userRepository.findOne({ where: { socialId: profile.id } });

    if (!user) {
      // If user doesn't exist, create a new one
      user = await this.userRepository.save({
        socialId: profile.id,
        email: profile.emails?.[0]?.value || '',
        firstName: profile.displayName,
        lastName: profile.name?.familyName,
        photo: profile.photos?.[0]?.value,
        // Other fields as necessary...
      });
    } else {
      // If user exists, update their profile if necessary
      user.firstName = profile.displayName || user.firstName;
      user.lastName = profile.name?.familyName || user.lastName;
      user.photo = profile.photos?.[0]?.value || user.photo;
      await this.userRepository.save(user);
    }

    // Generate JWT tokens
    const payload = { sub: user.id, email: user.email };
    const accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });
    const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });

    // Return the JWT tokens along with the user data
    return { accessToken, refreshToken, user };
  }

  /**
   * Handle redirect after social login (return tokens and user data).
   */
  async socialLoginRedirect(user: any) {
    // Your logic to handle what to do after successful login (maybe redirect to a dashboard)
    return {
      message: 'Login successful',
      user,
      accessToken: user.accessToken,
      refreshToken: user.refreshToken,
    };
  }
}
```

In the `validateOAuthLogin()` method:

- We first check if the user exists by matching their social ID (`profile.id`).
- If the user doesn't exist, we create a new user in the database and populate their profile fields using the data provided by the OAuth provider (e.g., `profile.displayName`, `profile.email`, `profile.photos`).
- If the user already exists, we update their profile with the latest information.
- Finally, we generate the JWT access and refresh tokens for the user.

---

### Step 3: **Two-Factor Authentication (2FA)**

Let‚Äôs now move on to **Two-Factor Authentication (2FA)**.

---

### **Two-Factor Authentication (2FA)** Setup Overview

In a typical 2FA system, the user authenticates with their username and password, and then a second factor (usually a time-based code sent via email, SMS, or WhatsApp) is required to complete the login.

We will implement 2FA in the following manner:

1. **Generate OTP (One-Time Password)**: When a user tries to log in, they will be prompted to enter the OTP sent to them via email, SMS, or WhatsApp.
2. **Verify OTP**: The OTP will be validated within a short time window to allow successful login.

#### 1. **Install Required Packages for OTP (SMS, Email, WhatsApp)**

For **SMS** and **Email**, we'll need third-party services. For example, we could use **Nodemailer** for email and **Twilio** for SMS.

```bash
npm install nodemailer twilio speakeasy
```

- `speakeasy`: A package to generate time-based OTPs (for both SMS/Email-based 2FA).
- `nodemailer`: To send OTPs via email.
- `twilio`: To send OTPs via SMS (or WhatsApp).

#### 2. **Generating OTPs with Speakeasy**

We'll use the `speakeasy` library to generate time-based OTPs that users can use for 2FA.

---

Got it! Based on your feedback, we can tailor the **Two-Factor Authentication (2FA)** mechanism to use your **API Gateway** and **SMPP Gateway** for SMS, and route through **WhatsApp** if the user has it installed. Here's a more flexible approach for handling these requirements:

### Step 1: **Modifying the 2FA Flow to Integrate with Your Gateway**

We will make the following changes:

1. **SMPP Gateway** for sending SMS, if the user doesn‚Äôt have WhatsApp installed.
2. **API Gateway** for sending both SMS and WhatsApp messages.
3. If the user has WhatsApp installed, the OTP will be sent via WhatsApp.

To achieve this, we will:

- **Detect whether WhatsApp is available** (e.g., based on user preferences or phone capabilities).
- Use the appropriate **API Gateway or SMPP Gateway** for SMS.
- Use the **API Gateway** for WhatsApp if the user prefers WhatsApp.

---

### Step 2: **2FA Implementation**

We will continue using `speakeasy` for generating OTPs and `axios` for making HTTP requests to the **API Gateway** or **SMPP Gateway**.

#### Install Required Packages (for sending requests)

```bash
npm install axios speakeasy
```

#### Example for OTP Generation and Sending (with API Gateway / SMPP Gateway Integration)

1. **Generate OTP using Speakeasy:**

We will generate a **TOTP** (Time-based One-Time Password) for the user and send it to the user via either SMS or WhatsApp based on the condition.

```ts
// src/auth/services/two-factor-auth.service.ts

import { Injectable } from '@nestjs/common';
import * as speakeasy from 'speakeasy';
import axios from 'axios';

@Injectable()
export class TwoFactorAuthService {
  /**
   * Generate and send OTP to the user via SMS or WhatsApp.
   * @param phoneNumber - The phone number to which OTP will be sent.
   * @param userHasWhatsApp - Boolean indicating whether the user has WhatsApp installed.
   */
  async sendOTP(phoneNumber: string, userHasWhatsApp: boolean): Promise<void> {
    // Generate OTP using speakeasy
    const otp = speakeasy.totp({
      secret: process.env.TOTP_SECRET, // Secret shared between client and server
      encoding: 'base32',
      step: 30, // Time interval for OTP validity in seconds
    });

    // Send OTP via WhatsApp if the user has WhatsApp installed
    if (userHasWhatsApp) {
      await this.sendWhatsAppOTP(phoneNumber, otp);
    } else {
      // Otherwise, send OTP via SMS using SMPP API or API Gateway
      await this.sendSMSOTP(phoneNumber, otp);
    }
  }

  /**
   * Sends OTP via WhatsApp using API Gateway.
   * @param phoneNumber - The phone number to which OTP will be sent.
   * @param otp - The OTP code generated.
   */
  private async sendWhatsAppOTP(phoneNumber: string, otp: string): Promise<void> {
    try {
      const response = await axios.post('https://your-api-gateway.com/send-whatsapp', {
        phoneNumber,
        message: `Your OTP code is: ${otp}`,
      });
      if (response.status !== 200) {
        throw new Error('Failed to send WhatsApp OTP');
      }
    } catch (error) {
      console.error('Error sending WhatsApp OTP:', error);
    }
  }

  /**
   * Sends OTP via SMS using SMPP API or API Gateway.
   * @param phoneNumber - The phone number to which OTP will be sent.
   * @param otp - The OTP code generated.
   */
  private async sendSMSOTP(phoneNumber: string, otp: string): Promise<void> {
    try {
      const response = await axios.post('https://your-sms-gateway.com/send-sms', {
        phoneNumber,
        message: `Your OTP code is: ${otp}`,
      });
      if (response.status !== 200) {
        throw new Error('Failed to send SMS OTP');
      }
    } catch (error) {
      console.error('Error sending SMS OTP:', error);
    }
  }

  /**
   * Verifies the OTP entered by the user.
   * @param userOtp - The OTP entered by the user.
   * @param userSecret - The secret shared between user and server.
   */
  verifyOTP(userOtp: string, userSecret: string): boolean {
    return speakeasy.totp.verify({
      secret: userSecret,
      encoding: 'base32',
      token: userOtp,
    });
  }
}
```

---

### Step 3: **Explanation**

1. **Generate OTP**:
   - We use `speakeasy.totp()` to generate a time-based OTP that changes every 30 seconds.
   - The secret is shared between the client (user's device) and server.

2. **Send OTP via WhatsApp or SMS**:
   - **If the user has WhatsApp installed**: The OTP will be sent through WhatsApp using your **API Gateway** (in the `sendWhatsAppOTP` method).
   - **If the user doesn't have WhatsApp**: The OTP will be sent via SMS using your **SMPP Gateway** or API Gateway (in the `sendSMSOTP` method).

3. **Verify OTP**:
   - When the user enters the OTP they received via WhatsApp/SMS, we verify the OTP using the `speakeasy.totp.verify()` method. If the OTP matches the expected value, the user is authenticated.

---

### Step 4: **Configuration for Using API Gateway and SMPP Gateway**

You can configure the following endpoints in your `.env` to handle SMS and WhatsApp integrations:

```env
# API Gateway Endpoints for SMS and WhatsApp
API_GATEWAY_URL=https://your-api-gateway.com
SMPP_GATEWAY_URL=https://your-sms-gateway.com

# TOTP Secret (should be securely shared with the client)
TOTP_SECRET=your-shared-secret
```

This configuration will ensure flexibility in switching between the two gateways depending on the user's preference or available service.

---

### Step 5: **Integrating 2FA in the Login Flow**

In your login flow, once the user enters their credentials, you will:

1. Check if they have 2FA enabled.
2. If they do, generate the OTP and send it via either WhatsApp or SMS, depending on whether WhatsApp is available.
3. Verify the OTP entered by the user and proceed with the login process.

Here‚Äôs an example of how to implement 2FA during login:

```ts
// src/auth/controllers/auth.controller.ts

@Controller('auth')
export class AuthController {
  constructor(private readonly twoFactorAuthService: TwoFactorAuthService) {}

  /**
   * Initiates the 2FA process by sending OTP to the user's phone.
   */
  @Post('login/2fa')
  async loginWith2FA(@Body() loginDto: LoginDto) {
    // Check if the user has 2FA enabled
    const user = await this.authService.validateUser(loginDto.email, loginDto.password);

    if (user?.isTwoFactorEnabled) {
      // Generate and send OTP to user's phone via WhatsApp/SMS
      await this.twoFactorAuthService.sendOTP(user.phoneNumber, user.hasWhatsApp);
    } else {
      // Proceed to the next authentication step (e.g., generate JWT tokens)
      return { message: 'Login successful' };
    }
  }

  /**
   * Verifies the OTP entered by the user.
   */
  @Post('verify-otp')
  async verifyOTP(@Body() otpDto: OTPDto) {
    const user = await this.authService.getUserById(otpDto.userId);

    if (this.twoFactorAuthService.verifyOTP(otpDto.otp, user.secret)) {
      return { message: 'OTP verified, login successful' };
    } else {
      throw new UnauthorizedException('Invalid OTP');
    }
  }
}
```

---

### Step 6: **Next Steps**

1. **Frontend Integration**: Implement the user interface where users can input the OTP after logging in with their credentials.
2. **Enhance OTP Expiration**: Consider adding an expiration window for OTP (e.g., 5 minutes).
3. **Backup Codes**: Implement backup codes for users who lose access to their phone.

---

### Conclusion

This solution integrates with your **API Gateway** and **SMPP Gateway**, providing flexibility for 2FA through SMS or WhatsApp. The system generates OTPs using **Speakeasy** and sends them through the appropriate gateway based on user preferences. You can also configure the system to handle the verification and authentication seamlessly.
