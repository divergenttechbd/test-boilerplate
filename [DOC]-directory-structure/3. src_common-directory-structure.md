# üìÅ `common/` directory Structure

    Src/
‚îÇ   ‚îú‚îÄ‚îÄ üì¶ common/                # Reusable utilities & cross-cutting concerns
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üß∑ decorators/        # Custom decorators
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üö® filters/           # Global exception filters
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üåÄ interceptors/      # Cross-cutting interceptors
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ‚ú® transform.interceptor.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üõ°Ô∏è guards/            # Route guards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üõ°Ô∏è pipes/            # Global & custom transformation logic for request validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üõ°Ô∏è types/            # Global utility types
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üõ°Ô∏è middleware/       # Cross-cutting request interceptors
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üîß utils/            # Helper functions

Perfect. Let‚Äôs begin with the **first sub-directory** in the `common/` folder:

---

### üìÅ `common/decorators/`

### $ ‚úÖ **Purpose**

This folder contains **custom decorators** that enhance or abstract logic used in controllers, services, or modules. NestJS supports custom decorators that can be applied at method, class, or parameter level to encapsulate repeated logic like extracting the current user, checking permissions, or injecting metadata.

---

#### üß± **Typical Use Cases**

- Extracting request-bound data (e.g., `@CurrentUser()`)
- Role-based access (`@Roles('admin')`)
- Custom headers (`@Public()`)
- Rate-limiting flags (`@Throttle()`)

---

#### üóÇÔ∏è Directory Structure Example

```
common/
‚îî‚îÄ‚îÄ decorators/
    ‚îú‚îÄ‚îÄ current-user.decorator.ts
    ‚îú‚îÄ‚îÄ roles.decorator.ts
    ‚îî‚îÄ‚îÄ public.decorator.ts
```

---

### üîé Example 1: `current-user.decorator.ts`

```ts
// common/decorators/current-user.decorator.ts

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user; // Assuming user is attached to request by AuthGuard
  },
);
```

#### ‚úÖ How to Use (e.g., in a Controller)

```ts
@Get('profile')
getProfile(@CurrentUser() user: any) {
  return user; // You get the authenticated user directly
}
```

---

#### üîé Example 2: `roles.decorator.ts`

```ts
// common/decorators/roles.decorator.ts

import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

#### ‚úÖ How to Use

```ts
@Roles('admin')
@UseGuards(RolesGuard)
@Get('admin-data')
getAdminData() {
  return 'Confidential data for admins only.';
}
```

---

#### üîé Example 3: `public.decorator.ts`

```ts
// common/decorators/public.decorator.ts

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

#### ‚úÖ How to Use

```ts
@Public()
@Get('login')
publicRoute() {
  return 'This route does not require authentication';
}
```

---

### üåê Global Usage

Decorators are **automatically globally usable** because they are stateless utility functions. You **don‚Äôt need to register them**. Just import where needed:

```ts
import { CurrentUser } from 'src/common/decorators/current-user.decorator';
```

---

### üìå Summary

| File                        | Purpose                                     |
|-----------------------------|---------------------------------------------|
| `current-user.decorator.ts` | Injects user info from request context      |
| `roles.decorator.ts`        | Attaches role metadata for guard usage      |
| `public.decorator.ts`       | Marks a route as public (no auth needed)    |

---
---

## üìÅ `common/filters/` ‚Äî Exception Handling Filters

### ‚úÖ **Purpose**

This directory contains custom **exception filters** that allow the application to centrally handle and format errors in a clean, uniform way ‚Äî whether it's a validation error, internal server error, or a known business rule failure.

---

## üß± Directory Structure Example

```
common/
‚îî‚îÄ‚îÄ filters/
    ‚îú‚îÄ‚îÄ all-exceptions.filter.ts        # Global fallback exception handler
    ‚îú‚îÄ‚îÄ http-exception.filter.ts        # Handles HttpExceptions only
    ‚îî‚îÄ‚îÄ validation-exception.filter.ts  # Optional: Custom format for validation errors
```

---

## üîé `all-exceptions.filter.ts` (Full Code with Comments)

```ts
// common/filters/all-exceptions.filter.ts

import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';

/**
 * Catch all exceptions ‚Äî fallback error handler.
 * This handles both known and unknown exceptions.
 */
@Catch() // No exception class passed, so it catches everything
export class AllExceptionsFilter implements ExceptionFilter {
  /**
   * `catch()` method is called when an exception is thrown.
   */
  catch(exception: unknown, host: ArgumentsHost): void {
    // Switch context to HTTP (useful for REST APIs)
    const ctx = host.switchToHttp();

    // Get the Express response and request objects
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // Determine appropriate HTTP status code
    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    // Get the response body or custom error message
    const message =
      exception instanceof HttpException
        ? exception.getResponse()
        : 'Internal server error';

    // Send back structured error response to client
    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(), // Helpful for logging & debugging
      path: request.url,
      error: message,
    });
  }
}
```

---

## üîé `http-exception.filter.ts` (Only for HttpException)

```ts
// common/filters/http-exception.filter.ts

import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
} from '@nestjs/common';
import { Request, Response } from 'express';

/**
 * This filter handles only HttpException errors (e.g., NotFoundException, ForbiddenException).
 */
@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // Extract HTTP status and message
    const status = exception.getStatus();
    const error = exception.getResponse();

    // Respond with a custom shape
    response.status(status).json({
      statusCode: status,
      error,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
```

---

## üîß How to Use Globally in `main.ts`

```ts
// main.ts

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AllExceptionsFilter } from './common/filters/all-exceptions.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Register exception filter globally (no DI needed)
  app.useGlobalFilters(new AllExceptionsFilter());

  await app.listen(3000);
}
bootstrap();
```

> ‚úÖ If you use dependencies (like logger service) in your filter, use `app.get()`:

```ts
app.useGlobalFilters(app.get(AllExceptionsFilter));
```

---

## üîß How to Use Locally (on a controller or route)

```ts
import { Controller, Get, UseFilters, HttpException, HttpStatus } from '@nestjs/common';
import { HttpExceptionFilter } from '../common/filters/http-exception.filter';

@UseFilters(HttpExceptionFilter)
@Controller('users')
export class UsersController {
  @Get()
  findAll() {
    // This will be caught by HttpExceptionFilter
    throw new HttpException('Forbidden access', HttpStatus.FORBIDDEN);
  }
}
```

---

---

## üîç File: `common/filters/validation-exception.filter.ts`

 a well-structured `validation-exception.filter.ts` designed to handle **class-validator**-based DTO validation errors in NestJS. It's written with **detailed comments**, **best practices**, and shows how to deliver a **developer- and user-friendly response format**.

```ts
// common/filters/validation-exception.filter.ts

import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  BadRequestException,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { ValidationError } from 'class-validator';

/**
 * A custom exception filter to handle validation errors
 * thrown by class-validator inside DTOs and pipes.
 */
@Catch(BadRequestException)
export class ValidationExceptionFilter implements ExceptionFilter {
  catch(exception: BadRequestException, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // Try to extract the validation errors from the exception response
    const exceptionResponse = exception.getResponse();
    const statusCode = exception.getStatus();

    // Check if the response contains validation errors in NestJS format
    const validationErrors =
      (exceptionResponse as any)?.message?.[0]?.constraints ||
      (exceptionResponse as any)?.message;

    // Format validation messages
    const formattedErrors = this.formatErrors(validationErrors);

    response.status(statusCode).json({
      statusCode,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: 'Validation failed',
      errors: formattedErrors, // Return cleaned and structured errors
    });
  }

  /**
   * Formats the raw validation error messages into a cleaner structure.
   * Supports both simple string arrays and class-validator error trees.
   */
  private formatErrors(errors: any): any[] {
    if (!Array.isArray(errors)) {
      return [errors];
    }

    // When the error comes from ValidationPipe, it could be an array of ValidationError objects
    return errors.map((error) => {
      // If it's a class-validator ValidationError object
      if (typeof error === 'object' && error.constraints) {
        return {
          field: error.property,
          errors: Object.values(error.constraints), // Collect all constraint messages
        };
      }

      // Otherwise just return the raw message
      return {
        field: null,
        errors: [error],
      };
    });
  }
}
```

---

## ‚úÖ When This Filter Is Useful

- You're using DTOs and `ValidationPipe` to validate incoming requests.
- You want to deliver structured and localized validation messages to the frontend.
- You want to make your API responses clean and standardized.

---

## üß™ Example Error Output

```json
{
  "statusCode": 400,
  "timestamp": "2025-04-17T18:44:21.897Z",
  "path": "/auth/register",
  "message": "Validation failed",
  "errors": [
    {
      "field": "email",
      "errors": [
        "email must be a valid email address"
      ]
    },
    {
      "field": "password",
      "errors": [
        "password must be longer than or equal to 6 characters"
      ]
    }
  ]
}
```

---

## ‚öôÔ∏è Register Globally in `main.ts` (with Dependency Injection)

If you're not using dependency injection (e.g., logger in the filter), do this:

```ts
// main.ts

import { ValidationExceptionFilter } from './common/filters/validation-exception.filter';

app.useGlobalFilters(new ValidationExceptionFilter());
```

If you need DI inside the filter, use:

```ts
app.useGlobalFilters(app.get(ValidationExceptionFilter));
```

---

## üß™ How to Trigger It

```ts
// sample DTO
export class RegisterDto {
  @IsEmail()
  email: string;

  @Length(6)
  password: string;
}

// controller
@Post('register')
register(@Body() dto: RegisterDto) {
  // Validation pipe will trigger this if validation fails
  return this.authService.register(dto);
}
```

---

## üß† Summary Table

| Filter File                    | Purpose                                                      | Global / Local |
|-------------------------------|--------------------------------------------------------------|----------------|
| `all-exceptions.filter.ts`    | Catches any kind of error (fallback for all uncaught errors) | Global         |
| `http-exception.filter.ts`    | Formats HTTP exceptions (401, 403, 404, etc.)                | Local / Global |
| `validation-exception.filter.ts` | (Optional) Customize validation errors with helpful fields | Optional       |

---

## üìÅ `common/interceptors/` ‚Äî Overview

### ‚úÖ Purpose

Interceptors in NestJS are used to implement **cross-cutting concerns** like:

- Logging
- Response transformation
- Error mapping
- Timeout handling
- Response caching
- Metrics/tracing

They sit **between the controller and route handler**, allowing you to **wrap, transform, or extend request/response lifecycles**.

---

## üìÇ Recommended Structure

```
common/
‚îî‚îÄ‚îÄ interceptors/
    ‚îú‚îÄ‚îÄ transform.interceptor.ts      # Global response shape transformation
    ‚îú‚îÄ‚îÄ timeout.interceptor.ts        # Sets timeout per request
    ‚îî‚îÄ‚îÄ errors.interceptor.ts         # Handles and transforms unhandled exceptions (optional)
```

---

### üîÑ 1. `transform.interceptor.ts`

**üìå Purpose:** Ensures all successful responses follow a **consistent response format**.

```ts
// common/interceptors/transform.interceptor.ts

import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

/**
 * Interceptor to wrap successful responses in a consistent format.
 */
@Injectable()
export class TransformInterceptor<T> implements NestInterceptor<T, any> {
  intercept(context: ExecutionContext, next: CallHandler<T>): Observable<any> {
    return next.handle().pipe(
      map((data) => ({
        statusCode: 200,
        success: true,
        timestamp: new Date().toISOString(),
        data, // actual response payload
      })),
    );
  }
}
```

### ‚úÖ Use Case

Keeps frontend responses predictable for all successful calls.

---

### ‚è∞ 2. `timeout.interceptor.ts`

**üìå Purpose:** Automatically **cancel long-running requests** with a timeout.

```ts
// common/interceptors/timeout.interceptor.ts

import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  RequestTimeoutException,
} from '@nestjs/common';
import { Observable, TimeoutError, throwError, timeout, catchError } from 'rxjs';

/**
 * Interceptor to enforce a maximum request processing time.
 */
@Injectable()
export class TimeoutInterceptor implements NestInterceptor {
  private readonly TIMEOUT = 10000; // ‚è± 10 seconds

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      timeout(this.TIMEOUT),
      catchError((err) => {
        if (err instanceof TimeoutError) {
          return throwError(() => new RequestTimeoutException('Request timed out'));
        }
        return throwError(() => err);
      }),
    );
  }
}
```

### ‚úÖ Use Case

Helps protect your app from slow third-party API calls or hanging DB queries.

---

### ‚ùó 3. `errors.interceptor.ts` (Optional)

**üìå Purpose:** Converts **unhandled thrown errors** into safe, developer-friendly messages.

```ts
// common/interceptors/errors.interceptor.ts

import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable, catchError, throwError } from 'rxjs';

/**
 * Intercepts and standardizes unknown/unexpected errors.
 */
@Injectable()
export class ErrorsInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      catchError((error) => {
        console.error('Unexpected error intercepted:', error);

        return throwError(() => ({
          statusCode: 500,
          message: 'Something went wrong internally',
          details: error?.message || null,
        }));
      }),
    );
  }
}
```

---

## üõ†Ô∏è How to Apply Globally (`main.ts`)

```ts
import { TransformInterceptor } from './common/interceptors/transform.interceptor';
import { TimeoutInterceptor } from './common/interceptors/timeout.interceptor';
import { ErrorsInterceptor } from './common/interceptors/errors.interceptor';

app.useGlobalInterceptors(
  new TransformInterceptor(),
  new TimeoutInterceptor(),
  new ErrorsInterceptor(), // optional
);
```

> Or if using **dependency-injected interceptors**:

```ts
app.useGlobalInterceptors(
  app.get(TransformInterceptor),
  app.get(TimeoutInterceptor),
);
```

---

## üß™ How to Apply to a Route or Controller

```ts
@UseInterceptors(TransformInterceptor, TimeoutInterceptor)
@Get('ping')
getPing() {
  return { message: 'pong' };
}
```

---
A **custom logging interceptor** is a fantastic way to trace every request and its corresponding response along with the time it took. It‚Äôs extremely useful for:

- üêû Debugging
- üìà Performance monitoring
- üìä Logging request-response cycles
- üß© Tracing issues by correlating with request ID/user info

---

## üìÑ `logging.interceptor.ts`

> We'll place this file in:  
> `src/common/interceptors/logging.interceptor.ts`  
> _(Or move it to `src/logging/` if you prefer separation ‚Äî we‚Äôll cover both options.)_

---

### ‚úÖ Features of this Interceptor

- Logs incoming request method and route
- Logs request body (safely)
- Logs time taken
- Logs response payload
- Includes optional request ID and user ID tracking using `AsyncLocalStorage` (via `async-context.ts`)

---

## üîß `logging.interceptor.ts` ‚Äî Fully Commented Code

```ts
// common/interceptors/logging.interceptor.ts

import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  Logger,
} from '@nestjs/common';
import { Observable, tap } from 'rxjs';
import { Request, Response } from 'express';
import { Reflector } from '@nestjs/core';
import { AsyncContext } from '../../logging/async-context'; // Optional: track request ID & user

/**
 * Interceptor to log incoming requests and outgoing responses with duration.
 */
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger(LoggingInterceptor.name);

  constructor(
    private readonly reflector: Reflector,
    private readonly asyncContext: AsyncContext, // Optional for advanced logging
  ) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const now = Date.now(); // ‚è±Ô∏è Start time
    const ctx = context.switchToHttp();
    const request = ctx.getRequest<Request>();
    const response = ctx.getResponse<Response>();

    const { method, originalUrl, body } = request;
    const requestId = this.asyncContext.get('requestId'); // Optional
    const userId = this.asyncContext.get('userId'); // Optional

    this.logger.log(
      `[${method}] ${originalUrl} | requestId=${requestId || '-'} | userId=${
        userId || '-'
      }`,
    );

    // Optional: Log body for POST/PUT/PATCH
    if (['POST', 'PUT', 'PATCH'].includes(method)) {
      this.logger.debug(`Request Body: ${JSON.stringify(body)}`);
    }

    return next.handle().pipe(
      tap((data) => {
        const duration = Date.now() - now; // ‚è≤Ô∏è Compute duration

        this.logger.log(
          `[${method}] ${originalUrl} | ${response.statusCode} | ${duration}ms`,
        );

        // Optional: log response payload
        this.logger.debug(`Response: ${JSON.stringify(data)}`);
      }),
    );
  }
}
```

---

## üõ†Ô∏è How to Register Globally in `main.ts`

```ts
import { LoggingInterceptor } from './common/interceptors/logging.interceptor';

app.useGlobalInterceptors(app.get(LoggingInterceptor)); // use app.get() if dependencies are injected
```

> ‚ö†Ô∏è Make sure `LoggingInterceptor` is registered in your AppModule as a provider (if it has injected services like `AsyncContext`).

---

## üß™ Register on Specific Controller/Route

```ts
@UseInterceptors(LoggingInterceptor)
@Get('/profile')
getProfile(@Req() req: Request) {
  return { profile: req.user };
}
```

---

## üì¶ Bonus: Integration with `AsyncContext` for requestId/userId

If you're using `AsyncLocalStorage` to store per-request metadata (like request ID/user ID), you can inject `AsyncContext` into this interceptor and include it in every log line. This is a best practice for tracing requests across microservices/log systems.

> We already have: `src/logging/async-context.ts`

---

## ‚úÖ Summary

| Feature                   | Enabled     |
|---------------------------|-------------|
| Logs HTTP method + path   | ‚úÖ          |
| Logs request body         | ‚úÖ (selectively) |
| Logs response body        | ‚úÖ (optional) |
| Logs duration             | ‚úÖ          |
| Tracks requestId/userId   | ‚úÖ (optional via `AsyncContext`) |
| Route-specific control    | ‚úÖ          |
| Global usage              | ‚úÖ          |

---

## ‚úÖ Summary Table

| Interceptor             | Purpose                                             | Global Use | Route-Level Use |
|-------------------------|-----------------------------------------------------|------------|-----------------|
| `transform.interceptor.ts` | Uniform response format                            | ‚úÖ          | ‚úÖ               |
| `timeout.interceptor.ts`   | Timeout long requests                             | ‚úÖ          | ‚úÖ               |
| `errors.interceptor.ts`    | Convert unexpected errors into standard responses | ‚úÖ (opt)    | ‚úÖ               |

---

## üìÅ Directory: `common/guards/`

### ‚úÖ Purpose

This folder contains **custom NestJS Guards** that determine **whether a request can proceed** based on:

- Authentication (`JwtAuthGuard`)
- Authorization (`RolesGuard`)
- Context-based access (`PermissionsGuard`, `TenantGuard`)
- IP-based restrictions
- Rate limiting

> Guards run **before** any controller handler or pipe is executed.

---

## üìÅ Suggested Structure

```
common/
‚îî‚îÄ‚îÄ guards/
    ‚îú‚îÄ‚îÄ roles.guard.ts             # Role-based access control
    ‚îú‚îÄ‚îÄ permissions.guard.ts       # Fine-grained permission-based access
    ‚îú‚îÄ‚îÄ jwt-auth.guard.ts          # Authenticated user guard (usually extended)
    ‚îú‚îÄ‚îÄ public.guard.ts            # Allows anonymous access to public routes
    ‚îî‚îÄ‚îÄ tenant.guard.ts            # Multi-tenancy context validation
```

---

## üîê Example 1: `roles.guard.ts`

### üéØ Purpose

Only allow users with specific roles to access the route (e.g., `ADMIN`, `EDITOR`).

```ts
// common/guards/roles.guard.ts

import {
  CanActivate,
  ExecutionContext,
  Injectable,
  ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator'; // e.g., @Roles('ADMIN')
import { Role } from '../../constants/enums/role.enum'; // enum Role { ADMIN = 'ADMIN', USER = 'USER' }

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    // Get required roles from metadata
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (!requiredRoles || requiredRoles.length === 0) {
      return true; // No role required, allow access
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user || !requiredRoles.includes(user.role)) {
      throw new ForbiddenException('You do not have permission to access this resource.');
    }

    return true;
  }
}
```

---

### ‚úÖ Step 2: Define `@Roles()` Decorator

```ts
// common/decorators/roles.decorator.ts

import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';

/**
 * Set metadata for required roles.
 * @example @Roles('ADMIN')
 */
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

---

### ‚úÖ How to Use in a Controller

```ts
import { UseGuards } from '@nestjs/common';
import { RolesGuard } from '../common/guards/roles.guard';
import { Roles } from '../common/decorators/roles.decorator';

@UseGuards(RolesGuard)
@Roles('ADMIN')
@Get('/admin-only')
getAdminData() {
  return { secret: 'admin-only-content' };
}
```

---

## üìõ Example 2: `public.guard.ts` (Optional)

Sometimes you want to skip `JwtAuthGuard` on **public routes** like login, signup, or password reset.

```ts
// common/guards/public.guard.ts

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';

export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

```ts
// Extend JwtAuthGuard to skip if route is public

import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { IS_PUBLIC_KEY } from './public.guard';

@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) return true;

    const request = context.switchToHttp().getRequest();
    return !!request.user; // fallback auth check
  }
}
```

```ts
@Public()
@Post('/login')
login(@Body() dto: LoginDto) {
  // open route
}
```

---

## üåê Global Registration (Optional)

You can apply guards globally in `main.ts`:

```ts
import { RolesGuard } from './common/guards/roles.guard';

app.useGlobalGuards(app.get(RolesGuard));
```

Or register them in `app.module.ts` using providers.

---

### üîê `permissions.guard.ts`

#### ‚úÖ Purpose

Used to **restrict access to a route based on user permissions**. It evaluates metadata (e.g., required permissions set via a custom decorator) against the current user‚Äôs permission set.

#### üìÅ Directory

```bash
src/common/guards/permissions.guard.ts
```

#### üß† Use Case

- Allow only users with specific roles/permissions (e.g., `can_edit_post`, `admin:access`) to access certain routes.
- Often used with a `@Permissions()` custom decorator.

---

### üßæ Sample Code

```ts
// src/common/guards/permissions.guard.ts

import {
  CanActivate,
  ExecutionContext,
  Injectable,
  ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { PERMISSIONS_KEY } from '../decorators/permissions.decorator'; // Custom metadata key
import { Request } from 'express';

@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    // Extract required permissions from metadata
    const requiredPermissions =
      this.reflector.getAllAndOverride<string[]>(PERMISSIONS_KEY, [
        context.getHandler(),
        context.getClass(),
      ]);

    if (!requiredPermissions) {
      return true; // No permissions required
    }

    const request = context.switchToHttp().getRequest<Request>();
    const user = request.user;

    // Guard against unauthorized user
    if (!user || !user.permissions) {
      throw new ForbiddenException('Access denied.');
    }

    const userPermissions = user.permissions;

    // Check if all required permissions exist in the user's permissions
    const hasAllPermissions = requiredPermissions.every(permission =>
      userPermissions.includes(permission),
    );

    if (!hasAllPermissions) {
      throw new ForbiddenException(
        `Missing required permissions: ${requiredPermissions.join(', ')}`,
      );
    }

    return true;
  }
}
```

---

### üéØ How to Use

#### `permissions.decorator.ts` (supporting decorator)

```ts
// src/common/decorators/permissions.decorator.ts

import { SetMetadata } from '@nestjs/common';

export const PERMISSIONS_KEY = 'permissions';
export const Permissions = (...permissions: string[]) =>
  SetMetadata(PERMISSIONS_KEY, permissions);
```

#### Example Controller Use

```ts
// src/modules/posts/posts.controller.ts

import { Controller, Get, UseGuards } from '@nestjs/common';
import { PermissionsGuard } from 'common/guards/permissions.guard';
import { Permissions } from 'common/decorators/permissions.decorator';

@Controller('posts')
@UseGuards(PermissionsGuard)
export class PostsController {
  @Get()
  @Permissions('read:posts')
  findAll() {
    return 'List of posts';
  }
}
```

---

### üåê Global Usage (Optional)

You can register it as a global guard in `main.ts`:

```ts
import { PermissionsGuard } from './common/guards/permissions.guard';

app.useGlobalGuards(new PermissionsGuard(app.get(Reflector)));
```

> üîÅ Recommended: Use it on specific routes instead of globally to avoid conflicts with routes that don‚Äôt require permission checking.

---

### üè¢ `tenant.guard.ts`

#### ‚úÖ Purpose

Used in **multi-tenant applications** to ensure that:

- The user is accessing data scoped to their tenant
- Tenant ID from request (header, token, or route param) matches the authenticated user‚Äôs tenant ID

---

### üßæ Sample Code

```ts
// src/common/guards/tenant.guard.ts

import {
  CanActivate,
  ExecutionContext,
  Injectable,
  ForbiddenException,
} from '@nestjs/common';
import { Request } from 'express';

@Injectable()
export class TenantGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest<Request>();
    const user = request.user;

    // Assume tenant ID is passed as a custom header or param
    const requestedTenantId = request.headers['x-tenant-id'] || request.params['tenantId'];

    if (!requestedTenantId || !user?.tenantId) {
      throw new ForbiddenException('Tenant context missing.');
    }

    if (requestedTenantId !== user.tenantId) {
      throw new ForbiddenException('Access denied for this tenant.');
    }

    return true;
  }
}
```

---

### üß™ Controller Example

```ts
// src/modules/products/products.controller.ts

import { Controller, Get, Param, UseGuards } from '@nestjs/common';
import { TenantGuard } from 'common/guards/tenant.guard';

@Controller('tenants/:tenantId/products')
@UseGuards(TenantGuard)
export class ProductsController {
  @Get()
  getProducts(@Param('tenantId') tenantId: string) {
    return `Products for tenant ${tenantId}`;
  }
}
```

---

### ‚úÖ Best Practices

- Combine `TenantGuard` with `PermissionsGuard` for full RBAC and tenant isolation.
- You may use a custom decorator like `@Tenant()` to access the current tenant.

---

## ‚úÖ Summary: Guard Types

| Guard Name         | Purpose                                         | Example Use Case                         |
|--------------------|--------------------------------------------------|-------------------------------------------|
| `roles.guard.ts`   | Enforce access based on user role                | `@Roles('ADMIN')`                        |
| `permissions.guard.ts` | Fine-grained permission check             | `@Permissions('create-post')`            |
| `jwt-auth.guard.ts`| Authenticated user required                     | Default auth guard                        |
| `public.guard.ts`  | Allow anonymous access to specific routes        | `@Public()` for `/login`, `/register`    |
| `tenant.guard.ts`  | Enforce valid tenant or organization in context | Multi-tenant SaaS                         |

---

Great! Now, let's move on to the `common/utils/` directory. This directory typically contains utility functions and helper methods that are used across the application. These functions help streamline repetitive tasks, making the code more modular and maintainable.

---

### üîß **`common/utils/`**

#### ‚úÖ **Purpose:**

The `common/utils/` directory stores helper functions, utility classes, and methods that can be reused across the entire application. These can be functions for validation, transformation, or general-purpose operations that don‚Äôt fit into specific business logic but are necessary for the application‚Äôs overall functionality.

#### üìÅ **Directory Structure:**

```bash
src/common/utils/
  ‚îú‚îÄ‚îÄ date.utils.ts         # Date manipulation and formatting
  ‚îú‚îÄ‚îÄ uuid.utils.ts         # UUID generation and validation
  ‚îú‚îÄ‚îÄ validation.utils.ts   # Validation functions for inputs (e.g., email, phone number)
  ‚îú‚îÄ‚îÄ encryption.utils.ts   # Utility for encryption/decryption
  ‚îî‚îÄ‚îÄ logger.utils.ts       # Logger helper functions (optional)
```

#### üß† **Use Case:**

- Reusable functions for common tasks, such as formatting dates or generating unique identifiers.
- Helps in reducing redundancy, improving readability, and making the application DRY (Don't Repeat Yourself).

---

### üìú **Sample Code for Each File:**

---

#### 1. **`date.utils.ts`** (Date Manipulation Utilities)

This utility provides methods for handling dates, such as formatting or adding/subtracting days.

```ts
// src/common/utils/date.utils.ts

import { format, addDays, subDays } from 'date-fns';

/**
 * Format a given date into a string format
 * @param {Date} date - The date to format
 * @param {string} dateFormat - The format string
 * @returns {string} - The formatted date
 */
export const formatDate = (date: Date, dateFormat: string): string => {
  return format(date, dateFormat);
};

/**
 * Add days to the current date
 * @param {Date} date - The starting date
 * @param {number} daysToAdd - Number of days to add
 * @returns {Date} - The new date
 */
export const addDaysToDate = (date: Date, daysToAdd: number): Date => {
  return addDays(date, daysToAdd);
};

/**
 * Subtract days from the current date
 * @param {Date} date - The starting date
 * @param {number} daysToSubtract - Number of days to subtract
 * @returns {Date} - The new date
 */
export const subtractDaysFromDate = (date: Date, daysToSubtract: number): Date => {
  return subDays(date, daysToSubtract);
};
```

---

#### 2. **`uuid.utils.ts`** (UUID Generation Utility)

This utility provides functions to generate and validate UUIDs.

```ts
// src/common/utils/uuid.utils.ts

import { v4 as uuidv4 } from 'uuid';

/**
 * Generate a new UUID
 * @returns {string} - A newly generated UUID
 */
export const generateUUID = (): string => {
  return uuidv4();
};

/**
 * Validate if a string is a valid UUID
 * @param {string} id - The string to validate
 * @returns {boolean} - True if the string is a valid UUID, false otherwise
 */
export const isValidUUID = (id: string): boolean => {
  const regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
  return regex.test(id);
};
```

---

#### 3. **`validation.utils.ts`** (Input Validation Utility)

This utility provides common validation methods (e.g., for validating emails, phone numbers).

```ts
// src/common/utils/validation.utils.ts

/**
 * Validate an email address
 * @param {string} email - The email to validate
 * @returns {boolean} - True if the email is valid, false otherwise
 */
export const isValidEmail = (email: string): boolean => {
  const regex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return regex.test(email);
};

/**
 * Validate a phone number
 * @param {string} phone - The phone number to validate
 * @returns {boolean} - True if the phone number is valid, false otherwise
 */
export const isValidPhoneNumber = (phone: string): boolean => {
  const regex = /^\+?[1-9]\d{1,14}$/;
  return regex.test(phone);
};
```

---

#### 4. **`encryption.utils.ts`** (Encryption/Decryption Utility)

This utility provides methods to encrypt and decrypt sensitive information (e.g., passwords or personal data).

```ts
// src/common/utils/encryption.utils.ts

import * as crypto from 'crypto';

/**
 * Encrypt data using AES-256-CBC
 * @param {string} text - The text to encrypt
 * @param {string} secretKey - The encryption key
 * @returns {string} - The encrypted text
 */
export const encryptText = (text: string, secretKey: string): string => {
  const cipher = crypto.createCipher('aes-256-cbc', secretKey);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
};

/**
 * Decrypt data using AES-256-CBC
 * @param {string} encryptedText - The encrypted text
 * @param {string} secretKey - The encryption key
 * @returns {string} - The decrypted text
 */
export const decryptText = (encryptedText: string, secretKey: string): string => {
  const decipher = crypto.createDecipher('aes-256-cbc', secretKey);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
};
```

---

#### 5. **`logger.utils.ts`** (Logger Helper Utility)

This utility provides logger functions that can be used to log different levels of messages (e.g., info, warn, error).

```ts
// src/common/utils/logger.utils.ts

import { Logger } from '@nestjs/common';

/**
 * Log an info message
 * @param {string} message - The message to log
 */
export const logInfo = (message: string): void => {
  Logger.log(message, 'INFO');
};

/**
 * Log a warning message
 * @param {string} message - The message to log
 */
export const logWarning = (message: string): void => {
  Logger.warn(message, 'WARN');
};

/**
 * Log an error message
 * @param {string} message - The message to log
 */
export const logError = (message: string): void => {
  Logger.error(message, 'ERROR');
};
```

---

### üß© **How to Use Common Utilities:**

#### 1. **Using a Utility Globally:**

If you need to use these utilities throughout the application (globally), you can simply import them where needed. For example, if you need to use the `uuid.utils.ts` file in a service, do:

```ts
// In any service or module

import { generateUUID } from 'common/utils/uuid.utils';

const newUUID = generateUUID();
console.log(`Generated UUID: ${newUUID}`);
```

#### 2. **Using a Utility in a Specific Module:**

For specific modules, you can import utilities and use them in controllers, services, or anywhere they are needed.

```ts
// In a service

import { formatDate } from 'common/utils/date.utils';

@Injectable()
export class UserService {
  getUserProfile(userId: string) {
    const currentDate = new Date();
    const formattedDate = formatDate(currentDate, 'yyyy-MM-dd');
    console.log(`Formatted date: ${formattedDate}`);
  }
}
```

---

### Additional Utility Functions

---

#### 1. **`pagination.utils.ts`** (Pagination Helpers)

These functions help in handling pagination logic for API responses.

```ts
// src/common/utils/pagination.utils.ts

/**
 * Generate pagination metadata for API responses
 * @param {number} currentPage - The current page number
 * @param {number} pageSize - Number of items per page
 * @param {number} totalItems - Total number of items available
 * @returns {object} - Pagination metadata
 */
export const generatePaginationMeta = (
  currentPage: number,
  pageSize: number,
  totalItems: number,
) => {
  const totalPages = Math.ceil(totalItems / pageSize);
  return {
    currentPage,
    pageSize,
    totalItems,
    totalPages,
  };
};

/**
 * Paginate the data based on the current page and page size
 * @param {Array} data - The data to be paginated
 * @param {number} currentPage - The current page number
 * @param {number} pageSize - Number of items per page
 * @returns {Array} - The paginated data
 */
export const paginateData = (data: any[], currentPage: number, pageSize: number) => {
  const offset = (currentPage - 1) * pageSize;
  return data.slice(offset, offset + pageSize);
};
```

#### Use Case

When implementing pagination in an API that returns a list of items, use these functions to calculate the pagination metadata and slice the data accordingly.

---

#### 2. **`file.utils.ts`** (File Handling Utilities)

These utilities handle common file operations, such as validating file extensions or generating unique file names.

```ts
// src/common/utils/file.utils.ts

import * as path from 'path';

/**
 * Validate if the file has an allowed extension
 * @param {string} fileName - The name of the file to validate
 * @param {string[]} allowedExtensions - List of allowed file extensions (e.g., ['.jpg', '.png'])
 * @returns {boolean} - True if the file has a valid extension, false otherwise
 */
export const isValidFileExtension = (fileName: string, allowedExtensions: string[]): boolean => {
  const fileExtension = path.extname(fileName).toLowerCase();
  return allowedExtensions.includes(fileExtension);
};

/**
 * Generate a unique file name using a timestamp and original file name
 * @param {string} originalFileName - The original file name
 * @returns {string} - A unique file name
 */
export const generateUniqueFileName = (originalFileName: string): string => {
  const timestamp = Date.now();
  const fileExtension = path.extname(originalFileName);
  const baseName = path.basename(originalFileName, fileExtension);
  return `${baseName}-${timestamp}${fileExtension}`;
};
```

#### Use Case

These file-related utilities are useful when dealing with file uploads, ensuring valid file types are uploaded, and renaming files to prevent name conflicts.

---

#### 3. **`currency.utils.ts`** (Currency Formatting)

This utility provides methods to format currency, often needed in financial applications or when dealing with transactions.

```ts
// src/common/utils/currency.utils.ts

/**
 * Format a number as currency
 * @param {number} amount - The amount to format
 * @param {string} currencySymbol - The symbol of the currency (e.g., "$")
 * @returns {string} - The formatted currency string
 */
export const formatCurrency = (amount: number, currencySymbol: string = '$'): string => {
  return `${currencySymbol}${amount.toFixed(2)}`;
};

/**
 * Convert a currency amount from one currency to another
 * @param {number} amount - The amount to convert
 * @param {number} conversionRate - The rate of conversion (e.g., 1.2 for USD to EUR)
 * @returns {number} - The converted amount
 */
export const convertCurrency = (amount: number, conversionRate: number): number => {
  return amount * conversionRate;
};
```

#### Use Case

These functions are ideal for applications that need to display currency amounts or perform currency conversions for international transactions.

---

#### 4. **`random.utils.ts`** (Random Data Generation)

This utility generates random data, which can be useful for generating random strings, numbers, or tokens.

```ts
// src/common/utils/random.utils.ts

/**
 * Generate a random alphanumeric string of a given length
 * @param {number} length - The length of the generated string
 * @returns {string} - The random string
 */
export const generateRandomString = (length: number): string => {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
};

/**
 * Generate a random number between a minimum and maximum value
 * @param {number} min - The minimum value
 * @param {number} max - The maximum value
 * @returns {number} - A random number between min and max
 */
export const generateRandomNumber = (min: number, max: number): number => {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};
```

#### Use Case

These utilities are helpful for generating random tokens for user registration, generating random numbers for testing, or generating secure random strings for unique identifiers.

---

#### 5. **`string.utils.ts`** (String Manipulation Utilities)

This utility provides common string manipulation functions, such as capitalizing words or trimming spaces.

```ts
// src/common/utils/string.utils.ts

/**
 * Capitalize the first letter of a string
 * @param {string} str - The string to capitalize
 * @returns {string} - The string with the first letter capitalized
 */
export const capitalizeFirstLetter = (str: string): string => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * Remove extra spaces from a string (e.g., multiple spaces between words)
 * @param {string} str - The string to trim
 * @returns {string} - The string with extra spaces removed
 */
export const removeExtraSpaces = (str: string): string => {
  return str.replace(/\s+/g, ' ').trim();
};
```

#### Use Case

These string utilities are commonly used when dealing with user inputs or when formatting data for display (e.g., capitalizing first names or cleaning up extra spaces in user input).

---

#### 6. **`http.utils.ts`** (HTTP Response Utility)

This utility simplifies the process of returning standardized API responses with status codes.

```ts
// src/common/utils/http.utils.ts

/**
 * Send a standardized success response
 * @param {any} data - The data to return in the response
 * @param {string} message - A success message
 * @returns {object} - The formatted response object
 */
export const sendSuccessResponse = (data: any, message: string = 'Success') => {
  return {
    status: 'success',
    message,
    data,
  };
};

/**
 * Send a standardized error response
 * @param {string} message - The error message
 * @param {number} statusCode - The HTTP status code
 * @returns {object} - The formatted error response object
 */
export const sendErrorResponse = (message: string, statusCode: number = 500) => {
  return {
    status: 'error',
    message,
    statusCode,
  };
};
```

#### Use Case

This utility helps in standardizing responses across the application, making the API responses more consistent and easier to manage.

---

### üß© **How to Use These Utilities:**

#### 1. **Using in a Service:**

For example, in a service that handles user data:

```ts
// src/user/user.service.ts

import { generateRandomString } from 'common/utils/random.utils';
import { formatCurrency } from 'common/utils/currency.utils';
import { generateUUID } from 'common/utils/uuid.utils';

@Injectable()
export class UserService {
  createUser(userData: any) {
    const userId = generateUUID();
    const userCode = generateRandomString(8);
    const formattedBalance = formatCurrency(userData.balance);

    // Log the new user data
    console.log(`Created user: ${userId}, ${userCode}, Balance: ${formattedBalance}`);
  }
}
```

---

### ‚úÖ **Best Practices:**

- **Avoid overcomplicating** utility functions. Keep them simple and reusable.
- **Separation of concerns**: Utilities should not have any business logic. They are for general, reusable tasks.
- Use **environment variables** where needed, e.g., secret keys in `encryption.utils.ts`.

---

## ‚úÖ `common/pipes/` ‚Äì Global & custom transformation logic for request validation

### üîπ Purpose

Used to **transform**, **sanitize**, and **validate** incoming request data (query, body, params) globally or per-route.

---

### üìÑ `validation.pipe.ts` ‚Äì Global pipe (used in `main.ts`)

```ts
// common/pipes/validation.pipe.ts

import {
  ArgumentMetadata,
  BadRequestException,
  Injectable,
  PipeTransform,
  ValidationPipe,
} from '@nestjs/common';
import { plainToInstance } from 'class-transformer';
import { validate } from 'class-validator';

@Injectable()
export class CustomValidationPipe implements PipeTransform {
  // This method transforms and validates the incoming value
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) return value;

    // Convert plain object to class instance
    const object = plainToInstance(metatype, value);

    // Validate the transformed object using class-validator
    const errors = await validate(object, {
      whitelist: true, // Strips properties not in DTO
      forbidNonWhitelisted: true,
      transform: true,
    });

    if (errors.length > 0) {
      throw new BadRequestException(errors);
    }
    return object;
  }

  // Check if the object needs to be validated
  private toValidate(metatype: any): boolean {
    const types = [String, Boolean, Number, Array, Object];
    return !types.includes(metatype);
  }
}
```

#### ‚úÖ Use in `main.ts`

```ts
app.useGlobalPipes(new CustomValidationPipe());
```

---

## ‚úÖ `common/filters/` ‚Äì Exception Handling

### üìÑ `all-exceptions.filter.ts` ‚Äì Catches all unhandled exceptions

```ts
// common/filters/all-exceptions.filter.ts

import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { LoggerService } from '@/infrastructure/logger/logger.service';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  constructor(private readonly logger: LoggerService) {}

  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const message =
      exception instanceof HttpException
        ? exception.getResponse()
        : (exception as any).message || 'Internal server error';

    const logContext = {
      method: request.method,
      url: request.url,
      status,
      message,
      requestId: request.headers['x-request-id'] || null,
    };

    // Log error details
    this.logger.error('Unhandled Exception', logContext);

    // Send structured error response
    response.status(status).json({
      success: false,
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
```

#### ‚úÖ Use in `main.ts`

```ts
app.useGlobalFilters(new AllExceptionsFilter(app.get(LoggerService)));
```

---

## ‚úÖ `common/types/` ‚Äì Global utility types

### üìÑ Examples

```ts
// common/types/paginated-response.type.ts
export interface Paginated<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
  };
}

// common/types/success-response.type.ts
export interface SuccessResponse<T> {
  success: true;
  data: T;
  message?: string;
}

// common/types/user-payload.type.ts
export interface UserPayload {
  id: string;
  email: string;
  roles: string[];
  permissions: string[];
}
```

---

## ‚úÖ `common/middleware/` ‚Äì Cross-cutting request interceptors

### üìÑ `request-id.middleware.ts`

```ts
// common/middleware/request-id.middleware.ts

import { Injectable, NestMiddleware } from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class RequestIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const requestId = req.headers['x-request-id'] || uuidv4();

    // Attach request ID to headers and request object
    req.headers['x-request-id'] = requestId;
    (req as any).requestId = requestId;

    next();
  }
}
```

### üìÑ `signed-access.middleware.ts`

```ts
// common/middleware/signed-access.middleware.ts

import { Injectable, NestMiddleware, UnauthorizedException } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { verifySignedUrl } from '@/helpers/signed-url.helper'; // assume we have this

@Injectable()
export class SignedAccessMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const token = req.query.token as string;

    if (!token || !verifySignedUrl(token)) {
      throw new UnauthorizedException('Invalid or expired signed token');
    }

    next();
  }
}
```

---

## üß™ Example: Using these from other modules

### ‚úÖ `main.ts` global usage

```ts
app.useGlobalPipes(new CustomValidationPipe());
app.useGlobalFilters(new AllExceptionsFilter(app.get(LoggerService)));
app.use(RequestIdMiddleware);
```

### ‚úÖ Module-level usage

```ts
// Inside a route guarded by Signed URL
@UseGuards(SignedAccessGuard) // or use middleware directly in routes using Express
@Get('private-asset')
getFile() {
  return this.assetsService.getPrivateAsset();
}
```

---

## ‚úÖ 1. **Guards Version of Middleware** (for Route-level Protection)

This converts your signed URL middleware into a reusable **`Guard`**, ideal for fine-grained control.

### üìÑ `common/guards/signed-access.guard.ts`

```ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Request } from 'express';
import { verifySignedUrl } from '@/helpers/signed-url.helper'; // Assume helper exists

@Injectable()
export class SignedAccessGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request: Request = context.switchToHttp().getRequest();
    const token = request.query.token as string;

    if (!token || !verifySignedUrl(token)) {
      throw new UnauthorizedException('Signed URL token is invalid or expired.');
    }

    return true; // Allow access if token is valid
  }
}
```

### ‚úÖ Usage in Controller

```ts
@UseGuards(SignedAccessGuard)
@Get('preview/:id')
previewFile(@Param('id') id: string) {
  return this.assetsService.getPreview(id);
}
```

---

## ‚úÖ 2. **Advanced Pipes**

### üîπ PaginationPipe ‚Äì Ensures proper pagination format

```ts
// common/pipes/pagination.pipe.ts

import { PipeTransform, Injectable, BadRequestException } from '@nestjs/common';

@Injectable()
export class PaginationPipe implements PipeTransform {
  transform(value: any) {
    const page = parseInt(value.page, 10) || 1;
    const limit = parseInt(value.limit, 10) || 10;

    if (page < 1 || limit < 1) {
      throw new BadRequestException('Page and limit must be positive numbers.');
    }

    return { page, limit };
  }
}
```

### üîπ TrimPipe ‚Äì Auto trims string inputs (good for search or inputs)

```ts
// common/pipes/trim.pipe.ts

import { PipeTransform, Injectable } from '@nestjs/common';

@Injectable()
export class TrimPipe implements PipeTransform {
  transform(value: any) {
    if (typeof value === 'string') {
      return value.trim();
    }

    if (typeof value === 'object' && value !== null) {
      Object.keys(value).forEach((key) => {
        if (typeof value[key] === 'string') {
          value[key] = value[key].trim();
        }
      });
    }

    return value;
  }
}
```

---

## ‚úÖ 3. **Exception Factory Standardization**

Centralized error format for better consistency and maintenance.

### üìÑ `common/exceptions/exception.factory.ts`

```ts
// common/exceptions/exception.factory.ts

import {
  BadRequestException,
  ForbiddenException,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';

export class ExceptionFactory {
  static badRequest(message: string, context?: Record<string, any>) {
    return new BadRequestException({ message, ...context });
  }

  static unauthorized(message = 'Unauthorized') {
    return new UnauthorizedException({ message });
  }

  static forbidden(message = 'Forbidden') {
    return new ForbiddenException({ message });
  }

  static notFound(message = 'Not Found') {
    return new NotFoundException({ message });
  }
}
```

### ‚úÖ Usage Example

```ts
throw ExceptionFactory.badRequest('Invalid input', { field: 'email' });
```

---

## ‚úÖ 4. **Auto-Registration in `app.module.ts`**

To automatically **register global filters, pipes, interceptors, and middleware**, we'll make the `AppModule` clean and centralized.

### üìÑ `src/app.module.ts`

```ts
import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common';
import { APP_FILTER, APP_INTERCEPTOR, APP_PIPE } from '@nestjs/core';

import { AllExceptionsFilter } from '@/common/filters/all-exceptions.filter';
import { CustomValidationPipe } from '@/common/pipes/validation.pipe';
import { LoggingInterceptor } from '@/logging/logging.interceptor';
import { RequestIdMiddleware } from '@/common/middleware/request-id.middleware';

// Import other shared modules, config, etc.
import { ConfigModule } from '@/config/config.module';
import { LoggerModule } from '@/infrastructure/logger/logger.module';
import { NotificationModule } from '@/infrastructure/notification/notification.module';
// ...

@Module({
  imports: [
    ConfigModule,
    LoggerModule,
    NotificationModule,
    // Add more shared modules here
  ],
  providers: [
    {
      provide: APP_PIPE,
      useClass: CustomValidationPipe, // Global validation
    },
    {
      provide: APP_FILTER,
      useClass: AllExceptionsFilter, // Global error handler
    },
    {
      provide: APP_INTERCEPTOR,
      useClass: LoggingInterceptor, // Global logging with request ID
    },
  ],
})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    // Add middleware globally
    consumer
      .apply(RequestIdMiddleware)
      .forRoutes({ path: '*', method: RequestMethod.ALL });
  }
}
```

---

## üß™ Summary: How to Use These Features

- **Global Pipes** like `CustomValidationPipe` are auto-injected.
- **Guards** like `SignedAccessGuard` are route-specific via `@UseGuards(...)`.
- **Middleware** like `RequestIdMiddleware` is auto-bound in `app.module.ts`.
- **ExceptionFactory** is used in any service/controller where custom error is needed.

---

## üîÑ Final Updated `common/` Directory Structure

```
common/
‚îú‚îÄ‚îÄ exceptions/
‚îÇ   ‚îî‚îÄ‚îÄ exception.factory.ts
‚îú‚îÄ‚îÄ filters/
‚îÇ   ‚îî‚îÄ‚îÄ all-exceptions.filter.ts
‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îî‚îÄ‚îÄ signed-access.guard.ts
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ request-id.middleware.ts
‚îÇ   ‚îî‚îÄ‚îÄ signed-access.middleware.ts
‚îú‚îÄ‚îÄ pipes/
‚îÇ   ‚îú‚îÄ‚îÄ validation.pipe.ts
‚îÇ   ‚îú‚îÄ‚îÄ pagination.pipe.ts
‚îÇ   ‚îî‚îÄ‚îÄ trim.pipe.ts
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ paginated-response.type.ts
‚îÇ   ‚îú‚îÄ‚îÄ success-response.type.ts
‚îÇ   ‚îî‚îÄ‚îÄ user-payload.type.ts
```

---
