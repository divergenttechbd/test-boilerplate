
Let's now deep dive into the üèóÔ∏è **`infrastructure/`** directory, starting with its structure and purpose. This layer is key to keeping our NestJS app clean, decoupled, and maintainable.

---

## üèóÔ∏è `infrastructure/` ‚Äî Purpose & Design

The `infrastructure/` directory handles all **low-level technical concerns** such as:

- Database initialization and providers
- Redis configuration
- Logging setup
- Queues for background processing
- File storage, cache management, etc.

It provides **technical building blocks** for the application but should avoid business logic.

---

## ‚úÖ Recommended Structure

```bash
src/
‚îî‚îÄ‚îÄ infrastructure/
    ‚îú‚îÄ‚îÄ üóÉ database/
    ‚îÇ   ‚îú‚îÄ‚îÄ database.module.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ database.providers.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ seed/
    ‚îÇ       ‚îú‚îÄ‚îÄ seed.module.ts
    ‚îÇ       ‚îî‚îÄ‚îÄ seed.service.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ üîÅ redis/
    ‚îÇ   ‚îú‚îÄ‚îÄ redis.module.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ redis.service.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ üìã logger/
    ‚îÇ   ‚îú‚îÄ‚îÄ logger.module.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ logger.service.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ üìã file-storage/
    ‚îÇ       ‚îú‚îÄ‚îÄ file-storage.module.ts
    ‚îÇ       ‚îú‚îÄ‚îÄ file-storage.service.ts
    ‚îÇ       ‚îú‚îÄ‚îÄ strategies/
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ local.strategy.ts
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ s3.strategy.ts
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ abstract-storage.strategy.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ üìã event-bus/
    ‚îÇ   ‚îú‚îÄ‚îÄ event-bus.module.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ event-bus.service.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ üìã rate-limiter/
    ‚îÇ   ‚îú‚îÄ‚îÄ rate-limiter.guard.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ rate-limiter.module.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ rate-limiter.service.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ üìã sse/
    ‚îÇ   ‚îú‚îÄ‚îÄ sse.module.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ sse.gateway.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ sse.service.ts
    ‚îÇ
    ‚îî‚îÄ‚îÄ üì© queue/
        ‚îú‚îÄ‚îÄ queue.module.ts
        ‚îî‚îÄ‚îÄ queue.service.ts
```

---

## üóÉÔ∏è `database/` ‚Äî Handles DB Connections & ORM Providers

### üìÑ `database.module.ts`

```ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigService } from '@nestjs/config';

@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        type: 'postgres',
        host: config.get('DB_HOST'),
        port: config.get<number>('DB_PORT'),
        username: config.get('DB_USER'),
        password: config.get('DB_PASS'),
        database: config.get('DB_NAME'),
        autoLoadEntities: true,
        synchronize: false, // Always false in prod
      }),
    }),
  ],
})
export class DatabaseModule {}
```

> üß† This connects to the DB using values from your `.env` and `ConfigService`.

---

### üìÑ `database.providers.ts`

Useful when you need to use raw connections with repositories manually:

```ts
import { DataSource } from 'typeorm';

export const databaseProviders = [
  {
    provide: 'DATA_SOURCE',
    useFactory: async () => {
      const dataSource = new DataSource({
        type: 'postgres',
        host: process.env.DB_HOST,
        port: Number(process.env.DB_PORT),
        username: process.env.DB_USER,
        password: process.env.DB_PASS,
        database: process.env.DB_NAME,
        entities: [__dirname + '/../../**/*.entity{.ts,.js}'],
        synchronize: false,
      });

      return dataSource.initialize();
    },
  },
];
```

---

### üìÑ `seed/` (Optional)

> Seeders to populate initial data during dev/staging.

#### `seed.service.ts`

```ts
import { Injectable, Logger } from '@nestjs/common';
import { User } from '@/modules/user/entities/user.entity';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';

@Injectable()
export class SeedService {
  private readonly logger = new Logger(SeedService.name);

  constructor(
    @InjectRepository(User)
    private userRepo: Repository<User>,
  ) {}

  async run() {
    const count = await this.userRepo.count();
    if (count === 0) {
      await this.userRepo.save({ name: 'Admin', email: 'admin@example.com' });
      this.logger.log('Seeded default admin user.');
    }
  }
}
```

---

## ‚úÖ Global Usage Example (In `app.module.ts` or other modules)

```ts
import { DatabaseModule } from '@/infrastructure/database/database.module';

@Module({
  imports: [DatabaseModule],
})
export class AppModule {}
```

---

## üß† Why Use Infra Layer?

| Benefit | Description |
|--------|-------------|
| üîÑ Decoupling | Keeps technical concerns away from business logic |
| ‚ôªÔ∏è Reusability | Reuse DB/Redis setup across modules |
| üß™ Testability | Swap implementations easily for tests |
| üîê Security | Separate access control for sensitive setups |

---
---

## ‚úÖ 1. `database/` ‚Äî Real-world Breakdown

### üìÅ `infrastructure/database/`

#### ‚úÖ Purpose

Manages:

- ORM configuration (TypeORM, Prisma, etc.)
- Database connection pool
- Database provider injection
- Optional: seeders/migrations

---

### üìÑ `database.module.ts`

```ts
// infrastructure/database/database.module.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigService } from '@nestjs/config';

@Module({
  imports: [
    // Async config ensures we can inject values from the config service
    TypeOrmModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        type: 'postgres',
        host: config.get('DB_HOST'),
        port: config.get<number>('DB_PORT'),
        username: config.get('DB_USER'),
        password: config.get('DB_PASS'),
        database: config.get('DB_NAME'),
        autoLoadEntities: true, // Loads all entities automatically
        synchronize: false,     // Should always be false in production
        logging: config.get<boolean>('DB_LOGGING') || false,
      }),
    }),
  ],
})
export class DatabaseModule {}
```

---

### üìÑ `database.providers.ts`

```ts
// infrastructure/database/database.providers.ts

import { DataSource } from 'typeorm';
import { ConfigService } from '@nestjs/config';

export const databaseProviders = [
  {
    provide: 'DATA_SOURCE', // Can be injected anywhere using @Inject('DATA_SOURCE')
    inject: [ConfigService],
    useFactory: async (config: ConfigService) => {
      const dataSource = new DataSource({
        type: 'postgres',
        host: config.get('DB_HOST'),
        port: Number(config.get('DB_PORT')),
        username: config.get('DB_USER'),
        password: config.get('DB_PASS'),
        database: config.get('DB_NAME'),
        entities: [__dirname + '/../../**/*.entity{.ts,.js}'],
        synchronize: false,
      });
      return dataSource.initialize();
    },
  },
];
```

---

### üìÑ `seed/seed.service.ts`

```ts
// infrastructure/database/seed/seed.service.ts

import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '@/modules/user/entities/user.entity';

@Injectable()
export class SeedService {
  private readonly logger = new Logger(SeedService.name);

  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  async run() {
    const userCount = await this.userRepository.count();
    if (userCount === 0) {
      await this.userRepository.save({
        name: 'Admin',
        email: 'admin@example.com',
        password: 'secure_password',
      });
      this.logger.log('Default admin user seeded');
    }
  }
}
```

---

### üìÑ `seed/seed.module.ts`

```ts
// infrastructure/database/seed/seed.module.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { SeedService } from './seed.service';
import { User } from '@/modules/user/entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [SeedService],
  exports: [SeedService], // So other modules can run it
})
export class SeedModule {}
```

---

## üß™ Use Case Scenarios

| Use Case | Example |
|----------|---------|
| ‚úÖ Connect PostgreSQL | Set up once in `database.module.ts` |
| üì¶ Use repository manually | Inject `DATA_SOURCE` using `@Inject('DATA_SOURCE')` |
| üå± Populate seed data | Run `SeedService.run()` during bootstrap |
| üß© Custom query runners | `dataSource.createQueryRunner()` to run complex DB ops |

---

## üåç How to Use DatabaseModule Globally

### üìÑ `app.module.ts`

```ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { DatabaseModule } from '@/infrastructure/database/database.module';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    DatabaseModule,
    // other modules...
  ],
})
export class AppModule {}
```

---

## üß© How to Use in Feature Module (e.g., User)

```ts
@Module({
  imports: [
    TypeOrmModule.forFeature([User]), // Load only needed entities
  ],
  providers: [UserService],
  controllers: [UserController],
})
export class UserModule {}
```

```ts
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private readonly userRepo: Repository<User>,
  ) {}

  async findAll() {
    return this.userRepo.find();
  }
}
```

---

### ‚úÖ Real-world Benefits of This Setup

| Benefit | Why It Matters |
|--------|----------------|
| üîå Decoupled | Keeps DB logic out of business layer |
| ‚ôªÔ∏è Reusable | You can reuse DB config across microservices |
| üß™ Testable | Easily mock or swap DB setup in test env |
| üì¶ Organized | Logical separation of concerns |

---
---

## ‚úÖ 2. `redis/` ‚Äî Real-World Setup, Code, and Use Cases

### üìÅ `infrastructure/redis/`

---

### ‚úÖ Purpose

This directory manages:

- Redis connection & client configuration
- Caching logic
- Pub/Sub channels (if needed)
- Reusable helper functions (e.g., `getOrSetCache`)
- Token/session management (optional)

---

### üìÅ Directory Structure

```bash
infrastructure/
‚îî‚îÄ‚îÄ redis/
    ‚îú‚îÄ‚îÄ redis.module.ts
    ‚îú‚îÄ‚îÄ redis.service.ts
    ‚îî‚îÄ‚îÄ helpers/
        ‚îî‚îÄ‚îÄ redis.helper.ts
```

---

## üîß Implementation

### üìÑ `redis.module.ts`

```ts
// infrastructure/redis/redis.module.ts

import { Module, Global } from '@nestjs/common';
import { RedisService } from './redis.service';
import { ConfigModule } from '@nestjs/config';

@Global() // Makes RedisService globally available
@Module({
  imports: [ConfigModule],
  providers: [RedisService],
  exports: [RedisService],
})
export class RedisModule {}
```

---

### üìÑ `redis.service.ts`

```ts
// infrastructure/redis/redis.service.ts

import { Injectable, OnModuleDestroy, Logger } from '@nestjs/common';
import * as Redis from 'ioredis';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class RedisService implements OnModuleDestroy {
  private readonly client: Redis.Redis;
  private readonly logger = new Logger(RedisService.name);

  constructor(private configService: ConfigService) {
    this.client = new Redis({
      host: this.configService.get('REDIS_HOST'),
      port: this.configService.get<number>('REDIS_PORT'),
    });

    this.client.on('connect', () => this.logger.log('Redis connected'));
    this.client.on('error', (err) => this.logger.error('Redis Error', err));
  }

  async get(key: string): Promise<string | null> {
    return this.client.get(key);
  }

  async set(key: string, value: string, ttlSeconds = 3600): Promise<void> {
    await this.client.set(key, value, 'EX', ttlSeconds);
  }

  async del(key: string): Promise<void> {
    await this.client.del(key);
  }

  getClient(): Redis.Redis {
    return this.client;
  }

  async onModuleDestroy() {
    await this.client.quit();
  }
}
```

---

### üìÑ `helpers/redis.helper.ts`

```ts
// infrastructure/redis/helpers/redis.helper.ts

import { RedisService } from '../redis.service';
import { Logger } from '@nestjs/common';

/**
 * Get data from cache or fetch fresh data and cache it.
 */
export const getOrSetCache = async <T>(
  redisService: RedisService,
  key: string,
  fetcher: () => Promise<T>,
  ttlSeconds = 3600,
): Promise<T> => {
  const logger = new Logger('getOrSetCache');

  const cached = await redisService.get(key);
  if (cached) {
    logger.log(`Cache HIT for key: ${key}`);
    return JSON.parse(cached);
  }

  logger.log(`Cache MISS for key: ${key}`);
  const fresh = await fetcher();
  await redisService.set(key, JSON.stringify(fresh), ttlSeconds);
  return fresh;
};
```

---

## üß™ Example Use Case

### üìÑ `user.service.ts`

```ts
// modules/user/services/user.service.ts

import { RedisService } from '@/infrastructure/redis/redis.service';
import { getOrSetCache } from '@/infrastructure/redis/helpers/redis.helper';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private readonly userRepo: Repository<User>,
    private readonly redisService: RedisService,
  ) {}

  async findAll(): Promise<User[]> {
    return getOrSetCache(this.redisService, 'users:all', () => {
      return this.userRepo.find();
    });
  }
}
```

---

## üåç How to Use RedisService Globally

Because of `@Global()` in `redis.module.ts`, you don't need to re-import the module in each feature.

### Just inject where needed

```ts
constructor(private readonly redisService: RedisService) {}
```

---

## üß† Real-World Benefits

| Feature | Benefit |
|--------|---------|
| ‚úÖ Global availability | No re-import required |
| ‚ö° Fast reads | Improve performance using cache |
| ‚ôªÔ∏è Auto refresh | Easily replace stale cache with `getOrSetCache` |
| üîå Decoupled logic | Cache strategy is separated from business logic |
| üì° Pub/Sub Ready | Can easily add Redis event channels later |

---

Absolutely! You're building a professional-grade logging system, and the clarity you're seeking is crucial. Let's walk through the complete setup for the `infrastructure/logger/` directory that supports:

- ‚úÖ Automatic request lifecycle logging  
- ‚úÖ Manual logging with `AppLoggerService`  
- ‚úÖ Environment-based log destinations (console, file, Grafana Loki)  
- ‚úÖ Exception capture and trace enrichment  
- ‚úÖ Seamless integration across modules

---

## ‚úÖ **Final Directory Tree ‚Äì `infrastructure/logger/`**

```
infrastructure/logger/
‚îú‚îÄ‚îÄ üì¶ logger.module.ts                # Registers the logger and dependencies globally
‚îú‚îÄ‚îÄ üß† logger.service.ts               # Core AppLoggerService with winston wrapper
‚îú‚îÄ‚îÄ ‚öôÔ∏è winston.config.ts               # Winston transports per environment (console, file, Loki)
‚îú‚îÄ‚îÄ ‚öôÔ∏è trace-context.service.ts        # AsyncLocalStorage-based request context holder
‚îú‚îÄ‚îÄ üß© tracing.middleware.ts           # Express middleware to start lifecycle & set context
‚îú‚îÄ‚îÄ üåÄ logger.interceptor.ts           # Global interceptor to capture request-response logs
‚îî‚îÄ‚îÄ üìÑ types/
    ‚îî‚îÄ‚îÄ logger.interface.ts           # Interface for log shape and levels
```

---

## üß© 1. `tracing.middleware.ts`

### ‚úÖ **Purpose**

Captures:

- `traceId` (for request tracking)
- `userId` (if authenticated)
- `role` (if authorized)
- `ip`, `userAgent`, and optionally body/deviceInfo

Sets these in `AsyncLocalStorage` via `TraceContextService`.

### ‚úÖ Code: `tracing.middleware.ts`

```ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { randomUUID } from 'crypto';
import { TraceContextService } from './trace-context.service';

@Injectable()
export class TracingMiddleware implements NestMiddleware {
  constructor(private readonly traceContext: TraceContextService) {}

  use(req: Request, res: Response, next: NextFunction) {
    const traceId = randomUUID();
    const userId = req['user']?.id || null;
    const role = req['user']?.role || null;
    const ip = req.ip || req.headers['x-forwarded-for'] || req.socket.remoteAddress;
    const userAgent = req.headers['user-agent'];

    // Run within AsyncLocalStorage context
    this.traceContext.runWithContext({
      traceId,
      userId,
      role,
      ip,
      userAgent,
    }, () => next());
  }
}
```

---

## üß† 2. `trace-context.service.ts`

### ‚úÖ **Purpose**

Holds `AsyncLocalStorage` context, exposing:

- `get()` methods for traceId, userId, etc.
- Available throughout app lifecycle.

### ‚úÖ Code: `trace-context.service.ts`

```ts
import { Injectable } from '@nestjs/common';
import { AsyncLocalStorage } from 'async_hooks';

export interface TraceContext {
  traceId: string;
  userId?: string;
  role?: string;
  ip?: string;
  userAgent?: string;
}

@Injectable()
export class TraceContextService {
  private readonly storage = new AsyncLocalStorage<TraceContext>();

  runWithContext(ctx: TraceContext, fn: () => void) {
    this.storage.run(ctx, fn);
  }

  get traceId() {
    return this.storage.getStore()?.traceId;
  }

  get userId() {
    return this.storage.getStore()?.userId;
  }

  get role() {
    return this.storage.getStore()?.role;
  }

  get ip() {
    return this.storage.getStore()?.ip;
  }

  get userAgent() {
    return this.storage.getStore()?.userAgent;
  }
}
```

---

## ‚öôÔ∏è 3. `winston.config.ts`

### ‚úÖ **Purpose**

Environment-based transport logic for Winston.

### ‚úÖ Code: `winston.config.ts`

```ts
import * as winston from 'winston';
import { utilities as nestWinstonModuleUtilities } from 'nest-winston';
import LokiTransport from 'winston-loki';

export function createWinstonLogger(env: string) {
  const transports = [];

  if (env === 'development') {
    transports.push(new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        nestWinstonModuleUtilities.format.nestLike(),
      ),
    }));
  } else if (env === 'staging' || env === 'uat') {
    transports.push(new winston.transports.File({
      filename: `logs/app-${env}.log`,
      dirname: 'logs',
      level: 'info',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    }));
  } else if (env === 'production') {
    transports.push(new LokiTransport({
      host: process.env.LOKI_URL,
      labels: { app: 'nestjs-app' },
      json: true,
      level: 'info',
    }));
  }

  return winston.createLogger({
    level: 'info',
    transports,
  });
}
```

---

## üß† 4. `logger.service.ts` (AppLoggerService)

### ‚úÖ **Purpose**

Centralized service to log across app using context.

### ‚úÖ Code: `logger.service.ts`

```ts
import { Injectable, LoggerService } from '@nestjs/common';
import { Logger } from 'winston';
import { Inject } from '@nestjs/common';
import { WINSTON_MODULE_NEST_PROVIDER } from 'nest-winston';
import { TraceContextService } from './trace-context.service';

@Injectable()
export class AppLoggerService implements LoggerService {
  constructor(
    @Inject(WINSTON_MODULE_NEST_PROVIDER) private readonly logger: Logger,
    private readonly traceContext: TraceContextService,
  ) {}

  private enrich(message: string, meta?: Record<string, any>) {
    return {
      message,
      context: {
        traceId: this.traceContext.traceId,
        userId: this.traceContext.userId,
        role: this.traceContext.role,
        ip: this.traceContext.ip,
        userAgent: this.traceContext.userAgent,
        ...meta,
      }
    };
  }

  log(message: string, meta?: Record<string, any>) {
    this.logger.info(this.enrich(message, meta));
  }

  error(message: string, meta?: Record<string, any>) {
    this.logger.error(this.enrich(message, meta));
  }

  warn(message: string, meta?: Record<string, any>) {
    this.logger.warn(this.enrich(message, meta));
  }

  debug(message: string, meta?: Record<string, any>) {
    this.logger.debug(this.enrich(message, meta));
  }

  verbose(message: string, meta?: Record<string, any>) {
    this.logger.verbose(this.enrich(message, meta));
  }
}
```

---

## üåÄ 5. `logger.interceptor.ts`

### ‚úÖ **Purpose**

Captures request duration, status code, and logs any exceptions.

### ‚úÖ Code: `logger.interceptor.ts`

```ts
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable, tap, catchError, throwError } from 'rxjs';
import { AppLoggerService } from './logger.service';
import { Request } from 'express';

@Injectable()
export class LoggerInterceptor implements NestInterceptor {
  constructor(private readonly logger: AppLoggerService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const req = context.switchToHttp().getRequest<Request>();
    const { method, originalUrl, body } = req;
    const start = Date.now();

    return next.handle().pipe(
      tap(() => {
        const duration = Date.now() - start;
        this.logger.log(`[${method}] ${originalUrl} - ${duration}ms`);
      }),
      catchError((err) => {
        const duration = Date.now() - start;
        this.logger.error(
          `[${method}] ${originalUrl} FAILED after ${duration}ms`,
          { error: err.message, body }
        );
        return throwError(() => err);
      }),
    );
  }
}
```

---

## üì¶ 6. `logger.module.ts`

```ts
import { Module, Global } from '@nestjs/common';
import { WinstonModule } from 'nest-winston';
import { createWinstonLogger } from './winston.config';
import { AppLoggerService } from './logger.service';
import { TracingMiddleware } from './tracing.middleware';
import { TraceContextService } from './trace-context.service';

@Global()
@Module({
  imports: [
    WinstonModule.forRootAsync({
      useFactory: () => ({
        logger: createWinstonLogger(process.env.NODE_ENV || 'development'),
      }),
    }),
  ],
  providers: [
    AppLoggerService,
    TracingMiddleware,
    TraceContextService,
  ],
  exports: [AppLoggerService, TraceContextService],
})
export class LoggerModule {}
```

---

## üìÑ 7. `types/logger.interface.ts`

Optional, but useful for strong typing and standardized log payloads.

---

## ‚úÖ How to Use

### 1. **Add globally in `AppModule`:**

```ts
@Module({
  imports: [
    LoggerModule, // Globally scoped
  ],
})
export class AppModule {}
```

### 2. **Register `TracingMiddleware`:**

In `main.ts`:

```ts
app.use(tracingMiddleware.use.bind(tracingMiddleware));
```

Or using `APP_MIDDLEWARE` injection in core module.

---

### 3. **Use in any module:**

```ts
constructor(private readonly logger: AppLoggerService) {}

this.logger.log('Something important');
```

---

## üìä Grafana Loki Setup

### ‚úÖ Installation (Docker Compose)

```yaml
# docker-compose.yml
loki:
  image: grafana/loki:2.7.3
  ports:
    - "3100:3100"
  command: -config.file=/etc/loki/local-config.yaml
  volumes:
    - ./loki-config.yaml:/etc/loki/local-config.yaml
```

### ‚úÖ Sample `LOKI_URL`

```
http://localhost:3100
```

### ‚úÖ Use with Grafana

1. Add Loki as a Data Source.
2. Set URL to `http://localhost:3100`.
3. Create a Dashboard ‚Üí Explore Logs ‚Üí Filter by traceId, message, etc.

---

Certainly! Let's delve into the topics you've requested:

---

## üì¶ Docker Compose for Grafana and Loki

ÓàÉSetting up Grafana and Loki using Docker Compose allows for a streamlined deployment processÓàÑÓàÉHere's a basic setupÓàÑÓàÜ

### üõ†Ô∏è Steps

1. **Create a Directory:**

   ```bash
   mkdir loki-stack
   cd loki-stack
   ``

ÓàÑÓàÜ

2. **Download Docker Compose File:**

   ```bash
   wget https://raw.githubusercontent.com/grafana/loki/v3.4.1/production/docker-compose.yaml -O docker-compose.yaml
   ``

ÓàÑÓàÜ

3. **Start the Stack:**

   ```bash
   docker-compose up -d
   ``

ÓàÑÓàÜ
ÓàÉThis setup includes Grafana, Loki, and Promtai. ÓàÉPromtail collects logs and forwards them to Lok.ÓàÑ ÓàÄciteÓàÇturn0search0ÓàÅÓàÜ

---

## üö® Alerting and Notifications from Lok

ÓàÉGrafana Loki supports alerting through its Ruler component, which evaluates LogQL expressions and triggers alers.ÓàÑÓàÜ

### üõ†Ô∏è Configuring Alerts

1. **Define Alerting Rules:**

   Create a YAML file with alerting rules:

   ```yaml
   groups:
     - name: example
       rules:
         - alert: HighErrorRate
           expr: |
             sum(rate({app="myapp"} |= "error" [5m])) by (job)
               /
             sum(rate({app="myapp"}[5m])) by (job)
               > 0.05
           for: 10m
           labels:
             severity: critical
           annotations:
             summary: High error rate detected
   ``

ÓàÑÓàÜ

2. **Configure the Ruler:**

   In Loki's configuration:

   ```yaml
   ruler:
     storage:
       type: local
       local:
         directory: /tmp/rules
     rule_path: /tmp/scratch
     alertmanager_url: http://localhost:9093
     ring:
       kvstore:
         store: inmemory
     enable_api: true
   ``

ÓàÜ

ÓàÉThis setup enables Loki to evaluate the defined rules and send alerts to Alertmanaer.ÓàÑ ÓàÄciteÓàÇturn0search1ÓàÅÓàÜ

---

## üìä Visualization Dashboards in Grafna

ÓàÉGrafana provides powerful visualization capabilities for logs collected by oki.ÓàÑÓàÜ

### üõ†Ô∏è Steps

1. **Add Loki as a Data Source:**
   - ÓàÉNavigate to Grafana's setings.ÓàÑ   - ÓàÉAdd a new data source and selectLoki.ÓàÑ   - ÓàÉSet the URL to `http://loki:100`.ÓàÑÓàÜ

2. **Explore Logs:**
   - ÓàÉUse the "Explore" section to query logs using ogQL.ÓàÑ   - ÓàÉBuild dashboards with panels visualizing specific log patterns or merics.ÓàÑ ÓàÄciteÓàÇturn0search2ÓàÅÓàÜ

---

## üß∞  `queue/` Diretory Details

### üìÅ Directory Struture

```
queue/
‚îú‚îÄ‚îÄ bullmq/
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.module.ts               # BullMQ-specific module
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.service.ts              # BullMQ service for queue and job handling
‚îÇ   ‚îî‚îÄ‚îÄ bullmq.processor.ts           # BullMQ job processor
‚îú‚îÄ‚îÄ rabbitmq/
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.module.ts             # RabbitMQ-specific module
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.service.ts            # RabbitMQ service for messaging
‚îÇ   ‚îî‚îÄ‚îÄ rabbitmq.processor.ts         # RabbitMQ message handler
‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îú‚îÄ‚îÄ queue.constants.ts             # Shared constants
‚îÇ   ‚îú‚îÄ‚îÄ queue.utils.ts                 # Utility functions
‚îÇ   ‚îî‚îÄ‚îÄ queue.interface.ts            # Common interface for all queue types
‚îú‚îÄ‚îÄ jobs/
‚îÇ   ‚îú‚îÄ‚îÄ retry.job.ts                   # Retry job logic
‚îÇ   ‚îú‚îÄ‚îÄ dlq.job.ts                     # Dead Letter Queue job
‚îÇ   ‚îî‚îÄ‚îÄ scheduled.job.ts               # Scheduled job example
‚îú‚îÄ‚îÄ queue.module.ts                    # Central queue module with dynamic engine switch
‚îî‚îÄ‚îÄ queue.config.ts                    # Dynamic config to choose queue engine and credentials
```

---

### üîß Key Components

- **BullMQ and RabbitMQ Moules:** ÓàÉProvide configurable integrations for jo queues.ÓàÑ
- **Procesors:** ÓàÉHandle the execution logic for queed jobs.ÓàÑ
- **Common Utilties:** ÓàÉContain shared constants and helper fnctions.ÓàÑ
- *Jobs:** ÓàÉDefine specific job types, including retry mechanisms, dead-letter queues (DLQ), and scheduld tasks.ÓàÑ
- **Queue Mdule:** ÓàÉAggregates all queue-related functionalities for easy integration into the main appicaion.ÓàÑÓàÜ

Walkthrough process:

1. **Overview & architecture**
2. **Dynamic engine selection using config**
3. **BullMQ and RabbitMQ integration**
4. **Job types: retry, DLQ, scheduled**
5. **Logging connectivity & failure via AppLogger**
6. **Usage guide for modules & global use**
7. **Real-world example use-cases**

---

### ‚úÖ Step 1: `queue.config.ts`

This file provides dynamic configuration to switch between **BullMQ**, **RabbitMQ**, or any other future queue engine.

#### üìÅ `queue/queue.config.ts`

```ts
// queue.config.ts

import { registerAs } from '@nestjs/config';

export type QueueEngine = 'bullmq' | 'rabbitmq';

export interface QueueConfig {
  engine: QueueEngine;
  bullmq: {
    redisHost: string;
    redisPort: number;
    redisPassword?: string;
    prefix: string;
  };
  rabbitmq: {
    url: string;
    queueName: string;
  };
}

export default registerAs('queue', (): QueueConfig => ({
  engine: process.env.QUEUE_ENGINE as QueueEngine || 'bullmq', // Default to BullMQ

  bullmq: {
    redisHost: process.env.BULLMQ_REDIS_HOST || 'localhost',
    redisPort: parseInt(process.env.BULLMQ_REDIS_PORT || '6379'),
    redisPassword: process.env.BULLMQ_REDIS_PASSWORD,
    prefix: process.env.BULLMQ_PREFIX || 'myapp',
  },

  rabbitmq: {
    url: process.env.RABBITMQ_URL || 'amqp://localhost:5672',
    queueName: process.env.RABBITMQ_QUEUE_NAME || 'myapp_queue',
  },
}));
```

---

### ‚úÖ Step 2: `queue.module.ts`

The centralized module that **loads the correct queue engine dynamically** and registers the appropriate service/provider accordingly.

#### üìÅ `queue/queue.module.ts`

```ts
// queue.module.ts

import { DynamicModule, Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import queueConfig, { QueueConfig } from './queue.config';
import { LoggerModule } from '@/infrastructure/logger/logger.module';

import { BullMQModule } from './bullmq/bullmq.module';
import { RabbitMQModule } from './rabbitmq/rabbitmq.module';

@Module({})
export class QueueModule {
  static register(): DynamicModule {
    return {
      module: QueueModule,
      imports: [
        ConfigModule.forRoot({
          load: [queueConfig],
          isGlobal: true,
        }),
        LoggerModule,
        // Queue Engine is conditionally loaded at runtime
        BullMQModule.registerIfEnabled(),
        RabbitMQModule.registerIfEnabled(),
      ],
    };
  }
}
```

---

### ‚úÖ Step 3: `queue.interface.ts`

A shared interface to define queue behavior across both BullMQ and RabbitMQ services.

#### üìÅ `queue/common/queue.interface.ts`

```ts
// queue.interface.ts

export interface IQueueService {
  enqueue(name: string, payload: any): Promise<void>;
  schedule(name: string, payload: any, delay: number): Promise<void>;
  retry(name: string, payload: any, retries: number): Promise<void>;
  onEvent?(event: string, listener: Function): void;
}
```

---

### ‚úÖ Step 4: BullMQ & RabbitMQ Modules

Each queue engine will:

- Read its own config section
- Register required processors/services
- Implement the `IQueueService` interface

We‚Äôll cover full implementations for:

- `bullmq.module.ts`
- `bullmq.service.ts`
- `bullmq.processor.ts`
- and same for `rabbitmq/*` shortly

---

### üîç Real-World Use Case

Let‚Äôs say you have a User module that sends a welcome email:

```ts
// user.service.ts
import { Inject } from '@nestjs/common';
import { IQueueService } from '@/queue/common/queue.interface';

@Injectable()
export class UserService {
  constructor(
    @Inject('QUEUE_SERVICE') private readonly queueService: IQueueService
  ) {}

  async createUser(data: any) {
    // user creation logic...

    await this.queueService.enqueue('sendWelcomeEmail', {
      userId: data.id,
      email: data.email,
    });
  }
}
```

‚úÖ The `QUEUE_SERVICE` will automatically use BullMQ or RabbitMQ based on `.env` configuration.

---

### ‚ö° Usage from AppModule

#### üìÅ `app.module.ts`

```ts
import { Module } from '@nestjs/common';
import { QueueModule } from '@/queue/queue.module';

@Module({
  imports: [
    QueueModule.register(),
  ],
})
export class AppModule {}
```

---

## üì¶ `queue/bullmq/` ‚Äî Full BullMQ Integration

---

### ‚úÖ Directory Structure

```
queue/
‚îú‚îÄ‚îÄ bullmq/
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.module.ts          # Registers BullMQ only if enabled
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.service.ts         # Service implementing IQueueService
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.processor.ts       # Job processor/worker handler
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.constants.ts       # BullMQ queue name constants
‚îÇ   ‚îî‚îÄ‚îÄ bullmq.utils.ts           # Optional helpers for jobs
```

---

## üîß `bullmq.module.ts`

Dynamically register **BullMQ** based on config.

```ts
// queue/bullmq/bullmq.module.ts

import { DynamicModule, Module } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { BullMQService } from './bullmq.service';
import { BullMQProcessor } from './bullmq.processor';
import { Queue } from 'bullmq';
import { LoggerModule } from '@/infrastructure/logger/logger.module';
import queueConfig from '../queue.config';

@Module({})
export class BullMQModule {
  static registerIfEnabled(): DynamicModule {
    return {
      module: BullMQModule,
      imports: [LoggerModule],
      providers: [
        {
          provide: 'QUEUE_SERVICE',
          useClass: BullMQService,
        },
        BullMQProcessor,
      ],
      exports: ['QUEUE_SERVICE'],
    };
  }
}
```

---

## üîß `bullmq.constants.ts`

Define queue job names and other identifiers here.

```ts
// queue/bullmq/bullmq.constants.ts

export const QUEUE_NAME = 'default';
export const JOB_SEND_WELCOME_EMAIL = 'sendWelcomeEmail';
```

---

## üß† `bullmq.service.ts`

Implements `IQueueService` and wraps BullMQ job logic.

```ts
// queue/bullmq/bullmq.service.ts

import { Injectable } from '@nestjs/common';
import { Queue } from 'bullmq';
import { IQueueService } from '../common/queue.interface';
import { ConfigService } from '@nestjs/config';
import { AppLoggerService } from '@/infrastructure/logger/logger.service';
import { QUEUE_NAME } from './bullmq.constants';

@Injectable()
export class BullMQService implements IQueueService {
  private queue: Queue;

  constructor(
    private readonly configService: ConfigService,
    private readonly logger: AppLoggerService,
  ) {
    const bullmqConfig = this.configService.get('queue.bullmq');

    this.queue = new Queue(QUEUE_NAME, {
      connection: {
        host: bullmqConfig.redisHost,
        port: bullmqConfig.redisPort,
        password: bullmqConfig.redisPassword,
      },
      prefix: bullmqConfig.prefix,
    });

    this.logger.info(`BullMQ Queue initialized: ${QUEUE_NAME}`);
  }

  async enqueue(name: string, payload: any): Promise<void> {
    await this.queue.add(name, payload);
    this.logger.debug(`BullMQ Job Enqueued: ${name}`, payload);
  }

  async schedule(name: string, payload: any, delay: number): Promise<void> {
    await this.queue.add(name, payload, { delay });
    this.logger.debug(`BullMQ Job Scheduled (delay=${delay}ms): ${name}`, payload);
  }

  async retry(name: string, payload: any, retries: number): Promise<void> {
    await this.queue.add(name, payload, {
      attempts: retries,
    });
    this.logger.debug(`BullMQ Job Retried (${retries}): ${name}`, payload);
  }
}
```

---

## ‚öôÔ∏è `bullmq.processor.ts`

Handles background job processing.

```ts
// queue/bullmq/bullmq.processor.ts

import { Process, Processor } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { JOB_SEND_WELCOME_EMAIL, QUEUE_NAME } from './bullmq.constants';
import { AppLoggerService } from '@/infrastructure/logger/logger.service';

@Processor(QUEUE_NAME)
export class BullMQProcessor {
  constructor(private readonly logger: AppLoggerService) {}

  @Process(JOB_SEND_WELCOME_EMAIL)
  async handleWelcomeEmail(job: Job) {
    this.logger.info(`Processing Job: ${job.name}`, {
      data: job.data,
    });

    try {
      const { email, userId } = job.data;

      // Simulate email sending
      this.logger.debug(`Sending welcome email to ${email}`);

      // TODO: integrate real mail service
    } catch (error) {
      this.logger.error(`Job failed: ${job.name}`, {
        error,
        job: job.data,
      });
      throw error;
    }
  }
}
```

---

## üß© `bullmq.utils.ts` (Optional)

Reusable helpers if needed (e.g., cleaning queues, admin tools).

---

## ‚úÖ How to Use in Any Module

Here‚Äôs how to enqueue a job from anywhere:

```ts
// any.service.ts
import { Inject, Injectable } from '@nestjs/common';
import { IQueueService } from '@/queue/common/queue.interface';
import { JOB_SEND_WELCOME_EMAIL } from '@/queue/bullmq/bullmq.constants';

@Injectable()
export class UserService {
  constructor(
    @Inject('QUEUE_SERVICE') private readonly queue: IQueueService,
  ) {}

  async registerUser(user: any) {
    // User registration logic...
    await this.queue.enqueue(JOB_SEND_WELCOME_EMAIL, {
      userId: user.id,
      email: user.email,
    });
  }
}
```

---

### ‚úÖ Logger Integration

All job processing, failures, retries, scheduling are automatically logged using the `AppLoggerService`.

---
Now let‚Äôs move on to the next integration for our `queue/` directory ‚Äî the **RabbitMQ** implementation.

---

## üêá `queue/rabbitmq/` ‚Äî Full RabbitMQ Integration

---

### ‚úÖ Directory Structure

```
queue/
‚îú‚îÄ‚îÄ rabbitmq/
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.module.ts         # Registers RabbitMQ-based QueueService
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.service.ts        # Implements enqueue, schedule, retry logic
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.consumer.ts       # Worker/consumer to process messages
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.constants.ts      # Constants for exchange, queue names
‚îÇ   ‚îî‚îÄ‚îÄ rabbitmq.utils.ts          # Helpers for message formatting, routing
```

---

## ‚öôÔ∏è `rabbitmq.constants.ts`

```ts
// queue/rabbitmq/rabbitmq.constants.ts

export const EXCHANGE_NAME = 'app.exchange';
export const QUEUE_NAME = 'app.queue';
export const ROUTING_KEY_WELCOME = 'welcome.email';
```

---

## üì¶ `rabbitmq.module.ts`

```ts
// queue/rabbitmq/rabbitmq.module.ts

import { Module } from '@nestjs/common';
import { RabbitMQService } from './rabbitmq.service';
import { RabbitMQConsumer } from './rabbitmq.consumer';
import { LoggerModule } from '@/infrastructure/logger/logger.module';

@Module({
  imports: [LoggerModule],
  providers: [
    {
      provide: 'QUEUE_SERVICE',
      useClass: RabbitMQService,
    },
    RabbitMQConsumer,
  ],
  exports: ['QUEUE_SERVICE'],
})
export class RabbitMQModule {}
```

---

## üß† `rabbitmq.service.ts`

```ts
// queue/rabbitmq/rabbitmq.service.ts

import { Injectable, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as amqplib from 'amqplib';
import { AppLoggerService } from '@/infrastructure/logger/logger.service';
import { EXCHANGE_NAME, QUEUE_NAME, ROUTING_KEY_WELCOME } from './rabbitmq.constants';
import { IQueueService } from '../common/queue.interface';

@Injectable()
export class RabbitMQService implements OnModuleInit, IQueueService {
  private channel: amqplib.Channel;
  private conn: amqplib.Connection;

  constructor(
    private readonly config: ConfigService,
    private readonly logger: AppLoggerService,
  ) {}

  async onModuleInit() {
    const uri = this.config.get<string>('queue.rabbitmq.uri');
    this.conn = await amqplib.connect(uri);
    this.channel = await this.conn.createChannel();

    await this.channel.assertExchange(EXCHANGE_NAME, 'direct', { durable: true });
    await this.channel.assertQueue(QUEUE_NAME, { durable: true });
    await this.channel.bindQueue(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY_WELCOME });

    this.logger.info(`RabbitMQ connected and ready`);
  }

  async enqueue(routingKey: string, data: any): Promise<void> {
    const buffer = Buffer.from(JSON.stringify(data));
    this.channel.publish(EXCHANGE_NAME, routingKey, buffer);
    this.logger.debug(`RabbitMQ Job Enqueued: ${routingKey}`, data);
  }

  async schedule(routingKey: string, data: any, delay: number): Promise<void> {
    this.logger.warn('RabbitMQ does not support native delay queue directly.');
    await this.enqueue(routingKey, data);
  }

  async retry(routingKey: string, data: any, retries: number): Promise<void> {
    for (let i = 0; i < retries; i++) {
      await this.enqueue(routingKey, data);
    }
    this.logger.debug(`RabbitMQ Retried (${retries}) times: ${routingKey}`, data);
  }
}
```

---

## üîÅ `rabbitmq.consumer.ts`

```ts
// queue/rabbitmq/rabbitmq.consumer.ts

import { Injectable, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AppLoggerService } from '@/infrastructure/logger/logger.service';
import * as amqplib from 'amqplib';
import { QUEUE_NAME } from './rabbitmq.constants';

@Injectable()
export class RabbitMQConsumer implements OnModuleInit {
  constructor(
    private readonly config: ConfigService,
    private readonly logger: AppLoggerService,
  ) {}

  async onModuleInit() {
    const conn = await amqplib.connect(this.config.get<string>('queue.rabbitmq.uri'));
    const channel = await conn.createChannel();
    await channel.assertQueue(QUEUE_NAME, { durable: true });

    channel.consume(
      QUEUE_NAME,
      async (msg) => {
        if (!msg) return;

        const payload = JSON.parse(msg.content.toString());
        this.logger.info(`RabbitMQ Job Received`, payload);

        try {
          if (msg.fields.routingKey === 'welcome.email') {
            await this.handleWelcomeEmail(payload);
          }

          channel.ack(msg);
        } catch (error) {
          this.logger.error(`RabbitMQ Job Failed`, { error });
          channel.nack(msg, false, false); // send to DLQ if configured
        }
      },
      { noAck: false },
    );
  }

  private async handleWelcomeEmail(data: any) {
    this.logger.debug(`Sending welcome email to ${data.email}`);
    // TODO: send email
  }
}
```

---

## ‚úÖ How to Use in Application

You can inject `QUEUE_SERVICE` just like with BullMQ:

```ts
import { Inject, Injectable } from '@nestjs/common';
import { IQueueService } from '@/queue/common/queue.interface';
import { ROUTING_KEY_WELCOME } from '@/queue/rabbitmq/rabbitmq.constants';

@Injectable()
export class UserService {
  constructor(@Inject('QUEUE_SERVICE') private readonly queue: IQueueService) {}

  async registerUser(user: any) {
    await this.queue.enqueue(ROUTING_KEY_WELCOME, {
      email: user.email,
      userId: user.id,
    });
  }
}
```

---

## üîÑ Choosing Between BullMQ and RabbitMQ (Dynamic)

In `queue.module.ts`, make the decision based on `QUEUE_DRIVER` in env config.

```ts
// queue/queue.module.ts

import { Module, DynamicModule } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { BullMQModule } from './bullmq/bullmq.module';
import { RabbitMQModule } from './rabbitmq/rabbitmq.module';

@Module({})
export class QueueModule {
  static register(): DynamicModule {
    const configService = new ConfigService();
    const driver = configService.get<string>('queue.driver');

    if (driver === 'rabbitmq') {
      return RabbitMQModule;
    }
    return BullMQModule;
  }
}
```

---

## ‚úÖ Configuration: `queue.config.ts`

```ts
// config/queue.config.ts

export default () => ({
  driver: process.env.QUEUE_DRIVER || 'bullmq',
  rabbitmq: {
    uri: process.env.RABBITMQ_URI,
  },
  bullmq: {
    redisHost: process.env.REDIS_HOST,
    redisPort: parseInt(process.env.REDIS_PORT || '6379'),
    redisPassword: process.env.REDIS_PASSWORD || undefined,
    prefix: process.env.BULLMQ_PREFIX || 'bull',
  },
});
```

---

### Would you like to proceed with

1. ‚úÖ Implementing **scheduled jobs**, retries, and DLQ patterns?
2. üß™ Real-world **example jobs & workflows** for your product?

---

### ‚úÖ **Queue Module ‚Äì Step 1: Implement Scheduled Jobs, Retries, and DLQ Patterns**

We‚Äôll build the following:

- **Scheduled Jobs** (cron, delayed, repeatable).
- **Retry Logic** on job failure.
- **Dead Letter Queue (DLQ)** handling for failed jobs beyond retry threshold.

üìÇ Directory Structure:

```
infrastructure/queue/
‚îú‚îÄ‚îÄ queue.module.ts
‚îú‚îÄ‚îÄ queue.service.ts
‚îú‚îÄ‚îÄ bullmq/
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.processor.ts
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ bullmq.config.ts
‚îú‚îÄ‚îÄ rabbitmq/
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ rabbitmq.config.ts
‚îú‚îÄ‚îÄ decorators/
‚îÇ   ‚îî‚îÄ‚îÄ queue-processor.decorator.ts
‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îî‚îÄ‚îÄ queue.interface.ts
‚îî‚îÄ‚îÄ jobs/
    ‚îú‚îÄ‚îÄ send-welcome-email.job.ts
    ‚îú‚îÄ‚îÄ report-generation.job.ts
    ‚îî‚îÄ‚îÄ scheduled-data-cleanup.job.ts
```

---

### üîÅ bullmq.config.ts (Dynamic Configuration with Retry, Schedule)

```ts
// bullmq.config.ts
import { QueueOptions } from 'bullmq';
import { ConfigService } from '@nestjs/config';

export const getBullMQOptions = (configService: ConfigService): QueueOptions => ({
  connection: {
    host: configService.get('REDIS_HOST'),
    port: configService.get<number>('REDIS_PORT'),
  },
  defaultJobOptions: {
    attempts: 3,                      // Retry 3 times on failure
    backoff: {
      type: 'exponential',           // Retry using exponential backoff
      delay: 3000,
    },
    removeOnComplete: true,
    removeOnFail: false,             // Keep failed jobs for DLQ
  },
});
```

---

### üí° Example Job ‚Äì scheduled-data-cleanup.job.ts

```ts
// scheduled-data-cleanup.job.ts
import { Job } from 'bullmq';
import { Injectable } from '@nestjs/common';
import { AppLoggerService } from '@/infrastructure/logger/logger.service';

@Injectable()
export class ScheduledDataCleanupJob {
  constructor(private readonly logger: AppLoggerService) {}

  async handle(job: Job): Promise<void> {
    this.logger.log(`Running cleanup job: ${job.name} - ID: ${job.id}`);

    try {
      // Your cleanup logic here
      console.log('Cleaning old records...');
      await new Promise((resolve) => setTimeout(resolve, 3000));

      this.logger.log(`Cleanup completed: ${job.name}`);
    } catch (error) {
      this.logger.error(`Cleanup failed: ${job.name}`, error.stack, job.id);
      throw error; // triggers retry
    }
  }
}
```

---

### üìÑ Processor for Jobs ‚Äì bullmq.processor.ts

```ts
// bullmq.processor.ts
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { ScheduledDataCleanupJob } from '../jobs/scheduled-data-cleanup.job';

@Processor('data-cleanup')
export class BullMQProcessor extends WorkerHost {
  constructor(private readonly cleanupJob: ScheduledDataCleanupJob) {
    super();
  }

  async process(job: any) {
    return this.cleanupJob.handle(job);
  }
}
```

---

### üß† Queue Service (for adding jobs)

```ts
// queue.service.ts
import { Injectable } from '@nestjs/common';
import { Queue } from 'bullmq';
import { InjectQueue } from '@nestjs/bullmq';

@Injectable()
export class QueueService {
  constructor(@InjectQueue('data-cleanup') private readonly cleanupQueue: Queue) {}

  // Schedule job (run every day at midnight)
  async scheduleCleanupJob() {
    await this.cleanupQueue.add(
      'midnight-cleanup',
      {},
      {
        repeat: { cron: '0 0 * * *' }, // every day midnight
      },
    );
  }

  // Add one-time retryable job
  async addReportJob(data: any) {
    await this.cleanupQueue.add('generate-report', data);
  }
}
```

---

### üß∞ Real-Time Use Cases ‚Äì Step 3

| Job Type                | Description                                | Config Features         |
|-------------------------|--------------------------------------------|--------------------------|
| Welcome Email Job       | On user registration                       | Retry on email failure  |
| Cleanup Job             | Runs nightly to purge old sessions         | Cron Schedule + Retry   |
| Report Generation Job   | Triggered manually via API or CRON         | Manual + Scheduled       |
| Dead Letter Job         | Catch and notify admin of permanent fails  | via `onFailed` hook      |

---

### üßπ DLQ Handling

To handle DLQ, setup another queue or event listener:

```ts
cleanupQueue.on('failed', async (job, err) => {
  if (job.attemptsMade >= job.opts.attempts) {
    // move to DLQ manually or notify admins
    console.error(`[DLQ] Job permanently failed: ${job.name}`, err);
  }
});
```

---

### ‚úÖ Logging with AppLoggerService

Each job uses `AppLoggerService` to track:

- Job start/end
- Retry/failures
- DLQ movement

No manual trace ID passing ‚Äî `AsyncLocalStorage` handles tracing context.

---

### üîÑ How to Trigger (Globally)

In your `AppService` or any feature module:

```ts
constructor(private readonly queueService: QueueService) {}

await this.queueService.scheduleCleanupJob();
await this.queueService.addReportJob({ userId: 123, dateRange: 'last_week' });
```

---

Now I‚Äôll continue with:

- üßµ rabbitmq.service.ts integration
- queue.module.ts for dynamic adapter switch (BullMQ or RabbitMQ)
- Worker registration strategies

---

Perfect. Let's continue and complete the **RabbitMQ integration** and the **dynamic adapter switch** inside the `queue/` directory. This step gives you the flexibility to choose **BullMQ or RabbitMQ** based on your environment or use case.

---

## üßµ Step 4: RabbitMQ Integration and Dynamic Adapter Switching

---

### ‚úÖ Directory Structure (Updated)

```
infrastructure/queue/
‚îú‚îÄ‚îÄ queue.module.ts                  # Dynamically selects and registers queue adapter
‚îú‚îÄ‚îÄ queue.service.ts                 # Wraps add/schedule methods for jobs
‚îú‚îÄ‚îÄ bullmq/
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.processor.ts
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ bullmq.config.ts
‚îú‚îÄ‚îÄ rabbitmq/
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ rabbitmq.config.ts
‚îú‚îÄ‚îÄ decorators/
‚îÇ   ‚îî‚îÄ‚îÄ queue-processor.decorator.ts
‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îî‚îÄ‚îÄ queue.interface.ts
‚îî‚îÄ‚îÄ jobs/
    ‚îî‚îÄ‚îÄ [job files...]
```

---

## üêá rabbitmq.config.ts

```ts
// rabbitmq.config.ts
import { ConfigService } from '@nestjs/config';

export const getRabbitMQConnection = (configService: ConfigService) => ({
  uri: configService.get<string>('RABBITMQ_URI', 'amqp://localhost:5672'),
  queueName: configService.get<string>('RABBITMQ_QUEUE', 'default_queue'),
});
```

---

## üì¶ rabbitmq.service.ts

```ts
// rabbitmq.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { connect, Channel } from 'amqplib';
import { getRabbitMQConnection } from './rabbitmq.config';
import { ConfigService } from '@nestjs/config';
import { AppLoggerService } from '@/infrastructure/logger/logger.service';

@Injectable()
export class RabbitMQService implements OnModuleInit {
  private channel: Channel;

  constructor(
    private readonly configService: ConfigService,
    private readonly logger: AppLoggerService
  ) {}

  async onModuleInit() {
    const { uri, queueName } = getRabbitMQConnection(this.configService);
    const connection = await connect(uri);
    this.channel = await connection.createChannel();

    await this.channel.assertQueue(queueName, { durable: true });
    this.logger.log(`RabbitMQ connected on ${uri}`);
  }

  async sendToQueue(jobName: string, payload: any) {
    const { queueName } = getRabbitMQConnection(this.configService);
    this.logger.log(`[RabbitMQ] Queuing job ${jobName}`, JSON.stringify(payload));

    return this.channel.sendToQueue(queueName, Buffer.from(JSON.stringify({ jobName, payload })));
  }

  async consume(callback: (msg: any) => Promise<void>) {
    const { queueName } = getRabbitMQConnection(this.configService);
    this.channel.consume(queueName, async (msg) => {
      if (msg !== null) {
        const content = JSON.parse(msg.content.toString());
        await callback(content);
        this.channel.ack(msg);
      }
    });
  }
}
```

---

## üîÑ Dynamic Queue Adapter Interface

```ts
// interfaces/queue.interface.ts
export interface IQueueAdapter {
  addJob(name: string, data: any): Promise<void>;
  scheduleJob?(name: string, data: any, scheduleOptions?: any): Promise<void>;
}
```

---

## üåâ queue.service.ts (Abstraction Layer)

```ts
// queue.service.ts
import { Injectable } from '@nestjs/common';
import { IQueueAdapter } from './interfaces/queue.interface';

@Injectable()
export class QueueService {
  constructor(private readonly adapter: IQueueAdapter) {}

  addJob(name: string, data: any): Promise<void> {
    return this.adapter.addJob(name, data);
  }

  scheduleJob(name: string, data: any, scheduleOptions?: any): Promise<void> {
    return this.adapter.scheduleJob?.(name, data, scheduleOptions);
  }
}
```

---

## üß© queue.module.ts (Dynamic Binding)

```ts
// queue.module.ts
import { Module, DynamicModule } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { QueueService } from './queue.service';
import { AppLoggerModule } from '../logger/logger.module';
import { BullMQService } from './bullmq/bullmq.service';
import { BullMQModule } from './bullmq/bullmq.module';
import { RabbitMQService } from './rabbitmq/rabbitmq.service';
import { RabbitMQModule } from './rabbitmq/rabbitmq.module';

@Module({})
export class QueueModule {
  static register(): DynamicModule {
    return {
      module: QueueModule,
      imports: [ConfigModule, AppLoggerModule],
      providers: [
        QueueService,
        {
          provide: 'QUEUE_ADAPTER',
          inject: [ConfigService],
          useFactory: (configService: ConfigService) => {
            const engine = configService.get('QUEUE_ENGINE', 'bullmq');
            if (engine === 'rabbitmq') {
              return new RabbitMQService(configService, new AppLoggerModule().logger);
            } else {
              return new BullMQService(configService, new AppLoggerModule().logger);
            }
          },
        },
        {
          provide: QueueService,
          useExisting: 'QUEUE_ADAPTER',
        },
      ],
      exports: [QueueService],
    };
  }
}
```

---

## üõ†Ô∏è .env Config Example

```env
QUEUE_ENGINE=bullmq      # or rabbitmq
REDIS_HOST=localhost
REDIS_PORT=6379

RABBITMQ_URI=amqp://localhost:5672
RABBITMQ_QUEUE=my_app_queue
```

---

## üß™ How to Use Globally

Import `QueueModule.register()` in `AppModule`:

```ts
// app.module.ts
import { QueueModule } from '@/infrastructure/queue/queue.module';

@Module({
  imports: [
    QueueModule.register(),
    // ...
  ],
})
export class AppModule {}
```

Use `QueueService` in any feature module:

```ts
constructor(private readonly queueService: QueueService) {}

await this.queueService.addJob('send-welcome-email', { userId: 99 });
```

---

## üìà Logging Support

You get:

- Job Queued
- Job Processed
- Job Failed
- Retry attempts
- DLQ logic (BullMQ), retry/ack (RabbitMQ)

All logs go through `AppLoggerService`, automatically enriched with `traceId`, `userId`, `IP`, etc.

---

Let's dive into the `infrastructure/database/` directory with a clean and scalable architecture ‚Äî covering **ORM setup**, **migrations**, **seeders**, **connection handling**, and integration with other modules. This approach focuses on **traceability**, **multi-tenant (if needed)**, **database health**, and **standard best practices**.

---

## üìÅ `infrastructure/database/` ‚Äì Purpose & Responsibilities

This directory handles:

- TypeORM (or your ORM of choice) configuration
- Connection initialization
- Entity management
- Migration and seed setup
- Custom database utilities (like transactions or health check)

---

## ‚úÖ Recommended Directory Structure

```ts
infrastructure/
‚îî‚îÄ‚îÄ database/
    ‚îú‚îÄ‚îÄ database.module.ts            // Exposes DB connection to the app
    ‚îú‚îÄ‚îÄ database.providers.ts         // Provider-based ORM injection
    ‚îú‚îÄ‚îÄ database.config.ts            // TypeORM or DataSource configuration
    ‚îú‚îÄ‚îÄ migration/                    // DB migration files
    ‚îú‚îÄ‚îÄ seed/                         // DB seeding scripts
    ‚îú‚îÄ‚îÄ entities/                     // Shared entities (non-domain specific)
    ‚îÇ   ‚îî‚îÄ‚îÄ base.entity.ts            // BaseEntity with timestamps, ID
    ‚îú‚îÄ‚îÄ interfaces/                   // Shared DB interfaces/types
    ‚îî‚îÄ‚îÄ utils/
        ‚îî‚îÄ‚îÄ transaction.helper.ts     // Helper to run operations in a transaction
```

---

## üß† 1. `database.config.ts`

Used by both app and CLI (like TypeORM CLI).

```ts
// infrastructure/database/database.config.ts

import { DataSourceOptions } from 'typeorm';
import * as dotenv from 'dotenv';
dotenv.config();

export const databaseConfig: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT || '5432', 10),
  username: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  synchronize: false, // avoid true in production
  logging: true,
  entities: [__dirname + '/../../**/*.entity.{ts,js}'],
  migrations: [__dirname + '/migration/*.{ts,js}'],
  migrationsRun: false,
};
```

---

## üß© 2. `database.module.ts`

```ts
// infrastructure/database/database.module.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { databaseConfig } from './database.config';

@Module({
  imports: [TypeOrmModule.forRoot(databaseConfig)],
  exports: [TypeOrmModule],
})
export class DatabaseModule {}
```

üìå **Use Case**: Import this in `AppModule` or a shared `InfrastructureModule`.

---

## üß™ 3. `database.providers.ts`

For use with custom repositories or external services.

```ts
// infrastructure/database/database.providers.ts

import { DataSource } from 'typeorm';
import { databaseConfig } from './database.config';

export const DatabaseProvider = {
  provide: 'DATA_SOURCE',
  useFactory: async () => {
    const dataSource = new DataSource(databaseConfig);
    return dataSource.initialize();
  },
};
```

---

## üìÑ 4. `entities/base.entity.ts`

```ts
// infrastructure/database/entities/base.entity.ts

import {
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  BaseEntity,
} from 'typeorm';

export abstract class AbstractBaseEntity extends BaseEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn({ type: 'timestamp with time zone' })
  createdAt: Date;

  @UpdateDateColumn({ type: 'timestamp with time zone' })
  updatedAt: Date;
}
```

üîÅ Inherit this in any domain entity:

```ts
export class User extends AbstractBaseEntity {
  // your columns here
}
```

---

## üìÇ 5. Migrations

Create migrations using TypeORM CLI:

```

npm run typeorm migration:create src/infrastructure/database/migration/Init
```

Example migration:

```ts
// migration/Init.ts

import { MigrationInterface, QueryRunner } from 'typeorm';

export class Init implements MigrationInterface {
  name = 'Init1698999999999';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      CREATE TABLE users (
        id UUID PRIMARY KEY,
        email VARCHAR NOT NULL
      );
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE users;`);
  }
}
```

Run migrations:

```bash
npm run typeorm migration:run
```

---

## üå± 6. Seeding Support (Optional)

Basic pattern for custom CLI seeding:

```ts
// seed/user.seed.ts

import { DataSource } from 'typeorm';
import { User } from 'src/modules/user/entities/user.entity';

export const seedUsers = async (dataSource: DataSource) => {
  const repo = dataSource.getRepository(User);

  await repo.save([
    repo.create({ email: 'admin@example.com' }),
    repo.create({ email: 'user@example.com' }),
  ]);
};
```

```ts
// seed/index.ts

import { DataSource } from 'typeorm';
import { databaseConfig } from '../database.config';
import { seedUsers } from './user.seed';

const seed = async () => {
  const dataSource = new DataSource(databaseConfig);
  await dataSource.initialize();
  await seedUsers(dataSource);
  await dataSource.destroy();
};

seed();
```

Run: `ts-node src/infrastructure/database/seed/index.ts`

---

## üß∞ 7. Utility Example - `transaction.helper.ts`

```ts
// utils/transaction.helper.ts

import { DataSource } from 'typeorm';

export const runInTransaction = async <T>(
  dataSource: DataSource,
  callback: (manager) => Promise<T>,
): Promise<T> => {
  return await dataSource.transaction(async (manager) => {
    return callback(manager);
  });
};
```

üß™ Use it in service:

```ts
await runInTransaction(this.dataSource, async (manager) => {
  await manager.save(Entity1, data);
  await manager.save(Entity2, otherData);
});
```

---

## ‚úÖ How to Use in a Module

Import the `DatabaseModule` in `AppModule` or a `SharedModule`.

```ts
@Module({
  imports: [DatabaseModule],
})
export class AppModule {}
```

Inject Repository:

```ts
constructor(
  @InjectRepository(User)
  private readonly userRepository: Repository<User>,
) {}
```

---

## üìå Optional Enhancements

- **Health Check Module** ‚Äì ping DB and expose via `/health`
- **Multi-tenancy support** ‚Äì custom connection strategies based on headers or JWT
- **Soft Delete** ‚Äì using `@DeleteDateColumn`

---

## üîå How It Helps

‚úÖ Separation of concerns  
‚úÖ CLI and app reusability  
‚úÖ Standardized migration & seed  
‚úÖ Future-proofing for production-grade DB management

---
---

## üß± `infrastructure/` Directory: Complete Breakdown

```
infrastructure/
‚îú‚îÄ‚îÄ file-storage/          ‚úÖ [New]
‚îÇ   ‚îú‚îÄ‚îÄ file-storage.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ file-storage.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ strategies/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ local.strategy.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ s3.strategy.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ abstract-storage.strategy.ts
‚îú‚îÄ‚îÄ event-bus/             ‚úÖ [New]
‚îÇ   ‚îú‚îÄ‚îÄ event-bus.module.ts
‚îÇ   ‚îî‚îÄ‚îÄ event-bus.service.ts
‚îú‚îÄ‚îÄ rate-limiter/          ‚úÖ [New]
‚îÇ   ‚îú‚îÄ‚îÄ rate-limiter.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ rate-limiter.guard.ts
‚îÇ   ‚îî‚îÄ‚îÄ rate-limiter.service.ts
‚îú‚îÄ‚îÄ sse/                   ‚úÖ [New]
‚îÇ   ‚îú‚îÄ‚îÄ sse.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ sse.gateway.ts
‚îÇ   ‚îî‚îÄ‚îÄ sse.service.ts
```

---

## ‚úÖ `file-storage/` ‚Äì Abstracted File System

### üîß Strategy Pattern for Local / S3 / Azure etc.

### üìÅ `abstract-storage.strategy.ts`

```ts
export abstract class FileStorageStrategy {
  abstract uploadFile(file: Express.Multer.File, key?: string): Promise<string>;
  abstract deleteFile(key: string): Promise<void>;
  abstract generateSignedUrl(key: string): Promise<string>;
}
```

### üìÅ `s3.strategy.ts` (simplified)

```ts
@Injectable()
export class S3StorageStrategy extends FileStorageStrategy {
  constructor(@InjectAwsService(S3) private readonly s3: S3) {
    super();
  }

  async uploadFile(file: Express.Multer.File, key?: string) {
    // Upload logic using AWS S3
  }

  async deleteFile(key: string) {
    // Delete logic
  }

  async generateSignedUrl(key: string) {
    // Presigned URL logic
  }
}
```

### üìÅ `file-storage.service.ts`

```ts
@Injectable()
export class FileStorageService {
  constructor(
    @Inject('STORAGE_STRATEGY') // Dynamically inject Local or S3
    private readonly strategy: FileStorageStrategy,
  ) {}

  upload(file: Express.Multer.File, key?: string) {
    return this.strategy.uploadFile(file, key);
  }

  signedUrl(key: string) {
    return this.strategy.generateSignedUrl(key);
  }

  delete(key: string) {
    return this.strategy.deleteFile(key);
  }
}
```

---


## ‚úÖ `event-bus/` ‚Äì App-wide Event Emitter

```ts
@Injectable()
export class EventBusService extends EventEmitter2 {
  constructor() {
    super({ wildcard: true });
  }

  emitEvent(event: string, payload: any) {
    this.emit(event, payload);
  }

  subscribe(event: string, handler: (...args: any[]) => void) {
    this.on(event, handler);
  }
}
```

Usage Example:

```ts
this.eventBus.emitEvent('user.registered', user);
```

---

## ‚úÖ `sse/` ‚Äì Server-Sent Events Broadcaster

```ts
@Controller('sse')
export class SseGateway {
  @Sse('notifications')
  sendEvents(@Req() req: Request): Observable<MessageEvent> {
    return interval(1000).pipe(map(() => ({ data: 'ping' })));
  }
}
```

Optional:
- Filter by user ID
- Use event-bus to emit messages into a stream
- Auth checks (bearer token from `req`)

---

## ‚úÖ `rate-limiter/` ‚Äì Request Throttling Support

```ts
@Injectable()
export class RateLimiterGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();

    const ip = request.ip;
    const key = `rate-limit:${ip}`;
    const limit = 100; // per hour

    const count = await this.redis.incr(key);

    if (count === 1) {
      await this.redis.expire(key, 3600);
    }

    if (count > limit) {
      throw new TooManyRequestsException('Rate limit exceeded');
    }

    return true;
  }
}
```

Apply this with:

```ts
@UseGuards(RateLimiterGuard)
@Get('/expensive-api')
handleRateLimitedEndpoint() { ... }
```

---

## ‚úÖ ENV Keys to Add

| Key | Description |
|--|--|
| `FILE_STORAGE_DRIVER` | `local`, `s3`, `azure`, `firebase`, etc. |
| `S3_BUCKET_NAME` | S3 bucket name |
| `S3_ACCESS_KEY_ID` | AWS access key |
| `S3_SECRET_ACCESS_KEY` | AWS secret key |
| `WEBSOCKET_REDIS_URL` | Redis URL for socket adapter |
| `ENABLE_WEBSOCKETS` | Enable/disable websockets |
| `ENABLE_RATE_LIMITING` | Enable global or per-route limiter |
| `SSE_RETRY_INTERVAL` | Optional retry timeout for disconnected clients |

---

## ‚úÖ Summary

With this structure, you've now enabled:

- ‚úÖ **Cloud-agnostic file storage** with signed URLs
- ‚úÖ **Real-time socket events** with optional Redis adapter
- ‚úÖ **Global event bus** to decouple side effects
- ‚úÖ **SSE support** for dashboards or live streams
- ‚úÖ **Rate-limiting** per route/user/IP
- ‚úÖ Modular, scalable, and testable service architecture

---