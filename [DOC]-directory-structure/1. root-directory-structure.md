---
This document explains the suggested **NestJS project directory structure** designed for scalability, maintainability, and real-time request lifecycle tracking. The structure is optimized for clean code practices, separation of concerns, modularity, and flexibility.

---

## Project Directory Tree

Here’s the overall structure of the project:

```bash

📦 project-root/                    # Project Root Directory of a NestJS project
├── 🧪 .env                          # Environment variables
├── 🧪 .env.example                  # Example env config for documentation
├── 🧪 .env.development             # Development-specific environment variables
├── 🧪 .env.production              # Production-specific environment variables
├── 🧪 .env.staging                 # Staging-specific environment variables
├── 📄 .eslintignore                # ESLint ignore rules
├── 📄 .eslintrc.js                 # ESLint configuration
├── 📄 .prettierrc                  # Code formatting rules
├── 🧾 commitlint.config.js         # Enforce commit message convention
├── 🧾 lint-staged.config.js        # Lint staged files before committing
├── 🐳 Dockerfile                   # Docker build instructions
├── 🐳 .dockerignore                # Ignore files for Docker context
├── 🧰 nest-cli.json                # NestJS CLI configuration
├── 🧰 tsconfig.json                # TypeScript configuration
├── 🧰 tsconfig.build.json          # TypeScript build config
├── 📜 package.json                 # Project dependencies and scripts
├── 📘 README.md                    # Project documentation root
│
├── 🐙 .github/                     # GitHub workflows & issue templates
│   ├── 📂 workflows/
│   │   ├── ⚙️ ci.yml               # CI workflow for building and testing
│   │   └── ⚙️ cd.yml                # CD workflow for deployment
│   ├── 📂 ISSUE_TEMPLATE/
│   │    ├── 🐞 bug_report.md
│   │    └── 🌟 feature_request.md
│   └── 📂 pull_request_template.md  # Pull request template use
│
├── 🪝 .husky/                      # Git hooks
│   ├── 🔧 pre-commit              # Lint & test before commit
│   └── 🔧 pre-push                # Validate before push
│
├── 📁 src/
│   ├── 🚀 main.ts                 # Application bootstrap
│   ├── 🧩 app.module.ts           # Root module
│
│   ├── ⚙️ config/                 # App-wide config
│   │   ├── 🛠️ app.config.ts               # General app settings (port, environment, version, etc.)
│   │   ├── 🛠️ auth.config.ts              # JWT, OAuth, and session settings
│   │   ├── 🛠️ cache.config.ts             # Redis/Memcached config
│   │   ├── 🛠️ mail.config.ts              # SMTP or mail provider settings
│   │   ├── 🛠️ sms-gateway.config.ts       # SMS providers (Twilio, Nexmo, etc.)
│   │   ├── 🛠️ notification.config.ts      # App-level push/email/notification toggles
│   │   ├── 🛠️ file.config.ts              # File upload settings, max sizes, S3/Bucket URLs
│   │   ├── 🛠️ kafka.config.ts             # Kafka-specific configuration (if used)
│   │   ├── 🛠️ queue.config.ts             # Bull, RabbitMQ queue retry, backoff settings
│   │   ├── 🛠️ rate-limit.config.ts        # API rate limit thresholds and time windows
│   │   ├── 🛠️ websocket.config.ts         # WebSocket settings (port, path, token check)
│   │   ├── 🛠️ event-stream.config.ts      # Kafka/EventBridge/Kinesis stream configs
│   │   ├── 🛠️ external-api.config.ts      # 3rd-party APIs (payment, analytics, etc.)
│   │   ├── 🛠️ message-broaker.config.ts   # RabbitMQ, Google Pub/Sub config
│   │   ├── 🛠️ logger.config.ts            # Log level, transports, formats
│   │   ├── 🛠️ swagger.config.ts           # API docs title, version, path
│   │   └── 🛠️ config.module.ts            # Bundles and exposes all configs via ConfigModule
│   ├── 📦 common/                 # Reusable utilities & cross-cutting concerns
│   │   ├── 🧷 decorators/         # Custom decorators
│   │   ├── 🚨 filters/           # Global exception filters
│   │   │   ├── all-exceptions.filter.ts        # Global fallback exception handler
│   │   │   ├── http-exception.filter.ts        # Handles HttpExceptions only
│   │   │   └── validation-exception.filter.ts  # Optional: Custom format for validation errors
│   │   ├── 🌀 interceptors/       # Cross-cutting interceptors
│   │   │   ├── transform.interceptor.ts      # Global response shape transformation
│   │   │   ├── timeout.interceptor.ts        # Sets timeout per request
│   │   │   └── errors.interceptor.ts         # Handles and transforms unhandled exceptions (optional)
│   │   ├── 🛡️ guards/            # Route guards
│   │   │   ├── roles.guard.ts             # Role-based access control
│   │   │   ├── permissions.guard.ts       # Fine-grained permission-based access
│   │   │   ├── jwt-auth.guard.ts          # Authenticated user guard (usually extended)
│   │   │   ├── public.guard.ts            # Allows anonymous access to public routes
│   │   │   └── tenant.guard.ts            # Multi-tenancy context validation
│   │   ├── 🛡️ pipes/            # Global & custom transformation logic for request validation
│   │   │   ├── validation.pipe.ts
│   │   │   ├── pagination.pipe.ts
│   │   │   └── trim.pipe.ts
│   │   ├── 🛡️ types/            # Global utility types
│   │   │   ├── paginated-response.type.ts
│   │   │   ├── success-response.type.ts
│   │   │   └── user-payload.type.ts
│   │   ├── 🛡️ middleware/       # Cross-cutting request interceptors
│   │   │   ├── request-id.middleware.ts
│   │   │   └── signed-access.middleware.ts
│   │   ├── 🔧 utils/              # Helper functions
│   │   │   ├── date.utils.ts         # Date manipulation and formatting
│   │   │   ├── uuid.utils.ts         # UUID generation and validation
│   │   │   ├── validation.utils.ts   # Validation functions for inputs (e.g., email, phone number)
│   │   │   ├── encryption.utils.ts   # Utility for encryption/decryption
│   │   │   └── logger.utils.ts       # Logger helper functions (optional)
│   ├── 🧰 helpers/                # General-purpose helpers
│   │   └── date.helper.ts   # Date/time format, duration, difference, Server to Local time convertion and all date related common helpers
│   │   ├── pagination.helper.ts        # Pagination builder for consistent API
│   │   ├── otp.helper.ts               # OTP generation
│   │   ├── slug.helper.ts              # Slug generation
│   │   ├── string.helper.ts            # String transformation
│   │   ├── number.helper.ts            # Number padding, formatting
│   │   ├── array.helper.ts             # Safe array operations
│   │   ├── file.helper.ts              # File size formatter, extension extraction
│   │   ├── url.helper.ts               # Safe URL builder and validator
│   │   ├── currency.helper.ts        # 💰 Format & parse money values
│   │   ├── jwt.helper.ts             # 🔐 Decode/verify JWTs manually
│   │   ├── locale.helper.ts          # 🌐 Language/region utils
│   │   ├── encryption.helper.ts     # 🔐 AES, HMAC-based encryption/decryption
│   │   ├── excel.helper.ts          # 📊 Excel file read/write & detail manupulation helpers
│   │   ├── pdf.helper.ts          # 📊 pdf file read/write and manupulate helpers
│   │   └── uuid.helper.ts           # 🆔 Generate UUIDs, tokens
│   ├── 🧱 constants/              # App constants (enums, messages)
│   │   ├── http-status-codes.constant.ts
│   │   ├── roles.constant.ts
│   │   ├── config.constant.ts
│   │   ├── message.constant.ts
│   │   ├── pagination.constant.ts
│   │   ├── environment.constant.ts
│   │   ├── email-templates.constant.ts
│   │   ├── file-types.constant.ts
│   │   ├── currency.constant.ts
│   │   └── constants.module.ts
│   ├── 🏗️ infrastructure/         # Infra layer: DB, Redis, Logger, Queue
│   │   ├── 🗃️ database/
│   │   │   ├── database.module.ts
│   │   │   └── database.providers.ts
│   │   │   │   └── seed/
│   │   │   │   │   ├── seed.module.ts
│   │   │   │   │   └── seed.service.ts
│   │   ├── 🔁 redis/
│   │   │   ├── redis.module.ts
│   │   │   ├── redis.service.ts
│   │   │   └── helpers/
│   │   │       └── redis.helper.ts
│   │   ├── 📋 logger/                  # Request lifecycle logging along with manual logging with RequestID and TraceID along with performance. With dynamic log configurable option like for dev log will be consoled. In UAT, will be stored in DB. In production, will be stored in Graphana Loki
│   │   │    ├── 📦 logger.module.ts                # Registers the logger and dependencies globally
│   │   │    ├── 🧠 logger.service.ts               # Core AppLoggerService with winston wrapper
│   │   │    ├── ⚙️ winston.config.ts               # Winston transports per environment (console, file, Loki)
│   │   │    ├── ⚙️ trace-context.service.ts        # AsyncLocalStorage-based request context holder
│   │   │    ├── 🧩 tracing.middleware.ts           # Express middleware to start lifecycle & set context
│   │   │    ├── 🌀 logger.interceptor.ts           # Global interceptor to capture request-response logs
│   │   │    └── 📄 types/
│                └── logger.interface.ts           # Interface for log shape and levels
│   │   ├── 📋 file-storage/
│   │   │   ├── file-storage.module.ts
│   │   │   ├── file-storage.service.ts
│   │   │   ├── strategies/
│   │   │   │   └──  local.strategy.ts
│   │   │   │       ├── s3.strategy.ts
│   │   │   │       └── abstract-storage.strategy.ts
│   │   ├── 📋 event-bus/
│   │   │   ├── event-bus.module.ts
│   │   │   └── event-bus.service.ts
│   │   ├── 📋 rate-limiter/
│   │   │   ├── rate-limiter.guard.ts
│   │   │   ├── rate-limiter.module.ts
│   │   │   └── rate-limiter.service.ts
│   │   ├── 📋 sse/
│   │   │   ├── sse.module.ts
│   │   │   ├── sse.gateway.ts
│   │   │   └── sse.service.ts
│   │   ├── 📩 queue/
│   │   │   ├── bullmq/
│   │   │   │   ├── bullmq.module.ts               # BullMQ-specific module
│   │   │   │   ├── bullmq.service.ts              # BullMQ service for queue and job handling
│   │   │   │   └── bullmq.processor.ts           # BullMQ job processor
│   │   │   ├── rabbitmq/
│   │   │   │   ├── rabbitmq.module.ts             # RabbitMQ-specific module
│   │   │   │   ├── rabbitmq.service.ts            # RabbitMQ service for messaging
│   │   │   │   └── rabbitmq.processor.ts         # RabbitMQ message handler
│   │   │   ├── common/
│   │   │   │   ├── queue.constants.ts             # Shared constants
│   │   │   │   ├── queue.utils.ts                 # Utility functions
│   │   │   │   └── queue.interface.ts            # Common interface for all queue types
│   │   │   ├── jobs/
│   │   │   │   ├── retry.job.ts                   # Retry job logic
│   │   │   │   ├── dlq.job.ts                     # Dead Letter Queue job
│   │   │   │   └── scheduled.job.ts               # Scheduled job example
│   │   │   ├── queue.module.ts                    # Central queue module with dynamic engine switch
│   │   │   └── queue.config.ts                    # Dynamic config to choose queue engine and credentials
│   ├── 🧾 logging/                # Request lifecycle logging
│   │   ├── 🧠 async-context.ts    # AsyncLocalStorage context
│   │   ├── 📄 logger.service.ts   # Contextual logger
│   │   ├── 🆔 request-id.middleware.ts
│   │   └── 📈 logging.interceptor.ts
│   ├── 🔄 interceptors/           # Global interceptors
│   │   ├── ✨ transform.interceptor.ts
│   │   ├── ⏰ timeout.interceptor.ts
│   │   ├── ❌ errors.interceptor.ts
│   │   ├── logging.interceptor.ts             # Request and response logging
│   │   ├── cache.interceptor.ts               # Caching response data
│   │   └── performance.interceptor.ts         # Performance measurement (e.g., response time)
│   ├── 📁 gateways/               # Real-time (WebSocket & SSE)
│   │   ├── 🌐 websocket/
│   │   │   └── 📄 notification.gateway.ts       # Real-time event push to client
│   │   ├── 🌐 sse/
│   │   │   └── 📄 sse.gateway.ts       # Real-time event push to client
│   │   ├── 🌐 webRTC/
│   │   │   └── 📄 rtc.gateway.ts       # Real-time communication to client
│   │   ├── 🤝 third-party/
│   │   │   ├── 📄 external-api.gateway.ts       # External API Call handler
│   │   │   ├── 📄 stripe.gateway.ts             # Stripe webhook handler
│   │   │   └── 📄 sms.gateway.ts                # Inbound SMS callback handling
│   │   └── 🛰️ event-stream/
│   │   │   └── 📄 kafka.gateway.ts              # Kafka-based inter-service gateway
│   ├── 🕵️ audit-log/                          # Tracks sensitive actions, user activity, and system behavior
│   │   ├── 📄 audit-log.module.ts            # AuditLogModule definition
│   │   ├── 📄 audit-log.service.ts           # Business logic for creating audit logs
│   │   ├── 🧬 entities/
│   │   │   └── 📄 audit-log.entity.ts        # TypeORM entity for storing audit logs
│   │   ├── 🛡️ interceptors/
│   │   │   └── 📄 audit.interceptor.ts       # Interceptor to capture request lifecycle automatically
│   │   ├── 🧩 decorators/
│   │   │   └── 📄 audit.decorator.ts         # Custom decorator to tag endpoints for audit logging
│   ├── 🧵 jobs/                             # Handles all async job processing
│   │   ├── 🧵 job.processor.ts             # Main listener: delegates incoming jobs to handler
│   │   ├── 📄 job.types.ts                 # Types/interfaces for job payloads (TS safety)
│   │   ├── 📁 handlers/                    # Job handlers for various tasks
│   │   │   ├── 📨 send-email.handler.ts    # Handle email sending logic
│   │   │   ├── 📱 send-sms.handler.ts      # Handle SMS dispatch logic
│   │   │   └── 📊 generate-report.handler.ts # Create reports and export to S3/PDF etc.
│   │   ├── 📁 schedulers/                  # Cron jobs to trigger tasks periodically
│   │   │   ├── 🕑 daily-report.scheduler.ts # Generates daily reports via queue
│   │   │   └── 🧹 data-cleanup.scheduler.ts # Weekly data cleanup or archiving
│   │   └── 📄 jobs.module.ts               # Job module registration (BullMQ Queue, Providers)
│   ├── 📣 events/                          # Application-wide event system
│   │   ├── 📄 events.module.ts            # EventEmitter setup and global registration
│   │   ├── 📁 emitters/                   # Emitters for triggering events
│   │   │   └── 📄 user-events.emitter.ts  # Example: Emit user-related events
│   │   ├── 📁 listeners/                  # Handlers that react to events
│   │   │   ├── 📄 user-events.listener.ts # Example: Send email, log audit, etc.
│   │   │   └── 📄 auth-events.listener.ts # Handle login/logout events
│   │   └── 📁 types/                      # Define shared types/interfaces for events
│   │       └── 📄 event-payloads.interface.ts
│   │
│   ├── 📣 notifications/          # Notification configuration and management system
│   │   ├── 📄 notifications.module.ts                     # NestJS module setup
│   │   ├── 🧠 notifications.service.ts                    # Notification dispatching service
│   │   ├── 🧩 strategies/                                  # Notification channel strategies (Strategy Pattern)
│   │   │   ├── 📄 email.strategy.ts
│   │   │   ├── 📄 sms.strategy.ts
│   │   │   ├── 📄 whatsapp.strategy.ts
│   │   │   ├── 📄 push.strategy.ts
│   │   │   ├── 📄 slack.strategy.ts
│   │   │   └── 📄 discord.strategy.ts
│   │   ├── 📦 interfaces/                                 # Base interface for all strategies
│   │   │   └── 📄 notification.interface.ts
│   │   ├── 📦 dto/                                        # DTO for sending notifications
│   │   │   └── 📄 send-notification.dto.ts
│   │   ├── 🧬 entities/                                   # DB entity to log notifications
│   │   │   └── 📄 notification-log.entity.ts
│   │   ├── 🔁 jobs/                                       # Background queue processing (BullMQ/Redis)
│   │   │   ├── 📄 notification.processor.ts
│   │   │   └── 📄 notification.job.ts
│   │   └── 📄 notification.config.ts                      # Channel priorities, fallback config
│   ├── 🔐 auth/                   # Auth module
│   │   ├── 📄 auth.module.ts
│   │   ├── 🧠 auth.service.ts
│   │   └── 🛡️ guards/
│   │           ├── 📄 jwt-auth.guard.ts
│   │           ├── 📄 role.guard.ts
│   │           └── 🧬 permission.guard.ts
│   ├── 🧩 modules/                # Feature-based business modules
│   │   └── 👤 user/
│   │   │   ├── 🎮 controllers/
│   │   │   │   └── 🧑‍💻 user.controller.ts
│   │   │   ├── 🧠 services/
│   │   │   │   └── 🧠 user.service.ts
│   │   │   ├── 🧬 entities/
│   │   │   │   └── 📄 user.entity.ts
│   │   │   ├── 📦 dto/
│   │   │   │   ├── 📄 create-user.dto.ts
│   │   │   │   └── 📄 update-user.dto.ts
│   │       └── 🧩 user.module.ts
│   ├── 📚 docs/                   # 📘 Swagger API docs
│   │   ├── 📄 swagger.config.ts      # Swagger configuration setup
│   │   ├── 📄 swagger.setup.ts       # Swagger bootstrapper
│   │   └── 📄 decorators/
│   │   │   └── 📄 permissions.decorator.ts  # Custom decorator to mark permission requirements
│   └── 🖼️ assets/                 # Static/public assets

```

---

## 🌱 Environment Files (`.env`, `.env.development`, `.env.production`, `.env.staging`, `.env.example`)

### 🔹 Purpose

Environment files allow you to define application configuration based on the deployment environment (dev, staging, prod, etc.). They store sensitive data or config values like API keys, DB URLs, ports, etc.

### 📁 Files Explained

| File Name            | Purpose                                                                 |
|---------------------|-------------------------------------------------------------------------|
| `.env`              | Generic fallback for environment variables if no specific env is loaded. |
| `.env.development`  | Used during development (`NODE_ENV=development`).                        |
| `.env.production`   | Used for production deployment (`NODE_ENV=production`).                  |
| `.env.staging`      | Used for staging environments.                                           |
| `.env.example`      | A reference template for required environment variables (no secrets).    |

### 🛠️ How It Works

NestJS doesn’t load `.env` files by itself — we use the `@nestjs/config` package to enable this.

#### 📦 Install Config Module

Make sure this package is installed:

```bash
npm install @nestjs/config
```

#### 📁 Example `.env.development`

```env
PORT=3000
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASS=password
```

#### ⚙️ src/config/configuration.ts

```ts
export default () => ({
  port: parseInt(process.env.PORT, 10) || 3000,
  database: {
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT, 10) || 5432,
    user: process.env.DB_USER,
    password: process.env.DB_PASS,
  },
});
```

#### 📥 Register Config Globally

```ts
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import configuration from './config/configuration';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, // ✅ Makes config available globally
      load: [configuration],
      envFilePath: `.env.${process.env.NODE_ENV || 'development'}`,
    }),
  ],
})
export class AppModule {}
```

---

### 💡 Usage in a Service

Let’s say you want to use the database config inside a service:

```ts
// src/modules/user/user.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class UserService {
  constructor(private configService: ConfigService) {}

  getDbConfig() {
    const dbHost = this.configService.get<string>('database.host');
    console.log('DB Host:', dbHost);
  }
}
```

---

### ✅ Summary

- Store environment-specific values in `.env.*` files.
- Use `@nestjs/config` to load and access them.
- Register it globally using `isGlobal: true`.
- Use `ConfigService` in any module or service to read the config.

---

Yes — we **do need to configure how the application selects the correct `.env` file** based on the environment (like development, staging, production). This is typically handled using the `NODE_ENV` environment variable.

---

## ✅ How to Select the Right `.env` File

NestJS with `@nestjs/config` supports selecting environment files dynamically. You just need to set `NODE_ENV` before starting the app.

### 🔹 Configuration in `AppModule`

In `src/app.module.ts`:

```ts
ConfigModule.forRoot({
  isGlobal: true,
  load: [configuration],
  envFilePath: `.env.${process.env.NODE_ENV || 'development'}`,
});
```

- If `NODE_ENV=production`, it loads `.env.production`.
- If `NODE_ENV=development`, it loads `.env.development`.
- If nothing is set, it falls back to `.env.development` by default.

---

### 📦 Setting `NODE_ENV`

#### ✅ In local development

You can use `cross-env` or set `NODE_ENV` directly when running the app.

##### 🧪 Option 1: With `cross-env` (cross-platform)

```bash
npx cross-env NODE_ENV=staging nest start
```

> Add this to your `package.json` scripts:

```json
"scripts": {
  "start:dev": "cross-env NODE_ENV=development nest start --watch",
  "start:staging": "cross-env NODE_ENV=staging nest start",
  "start:prod": "cross-env NODE_ENV=production node dist/main.js"
}
```

##### 🧪 Option 2: Native (Linux/macOS only)

```bash
NODE_ENV=production node dist/main.js
```

---

### 💡 Pro Tip for Docker or CI/CD

In `Dockerfile` or your deployment environment (e.g., Vercel, GitHub Actions, EC2, etc.), **make sure to set `NODE_ENV`** properly:

```Dockerfile
ENV NODE_ENV production
```

---

### ✅ Summary

| Task                         | Solution                                 |
|-----------------------------|------------------------------------------|
| Auto-select `.env` file     | Use `envFilePath: .env.${NODE_ENV}`     |
| Local development usage     | Set `NODE_ENV` via script or terminal    |
| Global usage in app         | `isGlobal: true` in `ConfigModule`       |
| In CI/CD or Docker          | Set `NODE_ENV` in environment or Dockerfile |

---

## 📁 Root Configuration Files - Purpose, Usage & Example

---

### 1. `.eslintrc.js` – **Linting Configuration**
>
> Enforces consistent code style and catches common bugs.

#### ✅ Purpose

- Helps maintain code quality.
- Prevents potentially dangerous patterns.
- Integrates well with VSCode and CI/CD.

#### ⚙️ Example

```js
module.exports = {
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'prettier'
  ],
  rules: {
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/explicit-module-boundary-types': 'off'
  }
};
```

#### 📥 Usage

- Automatically used by ESLint.
- Run manually via:

  ```bash
  npm run lint
  ```

#### 📦 In `package.json`

```json
"scripts": {
  "lint": "eslint 'src/**/*.ts'"
}
```

---

### 2. `.eslintignore` – **Ignore Patterns for Linter**
>
> Tells ESLint which files/directories to skip.

#### ✅ Example

```
dist
node_modules
logs
coverage
```

---

### 3. `.prettierrc` – **Code Formatting Rules**
>
> Ensures consistent code formatting across teams.

#### ✅ Example

```json
{
  "semi": true,
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "trailingComma": "all"
}
```

#### 📦 In `package.json`

```json
"scripts": {
  "format": "prettier --write 'src/**/*.ts'"
}
```

---

### 4. `commitlint.config.js` – **Enforce Git Commit Message Convention**
>
> Ensures your commit messages follow a standard (e.g., [Conventional Commits](https://www.conventionalcommits.org)).

 ✅ Example

```js
module.exports = {
  extends: ['@commitlint/config-conventional']
};
```

⚙️ How to use

1. Install:

   ```bash
   npm install --save-dev @commitlint/{config-conventional,cli}
   ```

2. Hook it with Husky:

   ```bash
   npx husky add .husky/commit-msg 'npx --no -- commitlint --edit "$1"'
   ```

---

### 5. `lint-staged.config.js` – **Lint and Format Files Before Commit**
>
> Run linters on only staged files (blazing fast CI/CD & commits).

#### ✅ Example

```js
module.exports = {
  '**/*.ts': ['eslint --fix', 'prettier --write']
};
```

### 6. .husky/ – Git Hooks Management

# ⚙️ Works with Husky

```bash
npx husky add .husky/pre-commit "npx lint-staged"
```

---
Absolutely! Let's dive deeper into the `.husky/` and `.github/` folders. These are super useful for automating development workflows and ensuring code quality and team consistency.

---

## 🐶 `.husky/` – Git Hooks Automation

### 📁 Tree Structure

```

.husky/
├── _/                        # Husky internal helper
│   └── husky.sh              # Shell helper script (auto-generated)
├── pre-commit                # Hook: runs before each commit
└── pre-push                  # Hook: runs before each push
```

---

### ✅ Purpose

Husky lets you **automate Git hooks** like:

- **pre-commit**: Run lint, tests, type checks, etc.
- **pre-push**: Ensure your code passes CI checks before pushing.
- **commit-msg**: Validate commit messages using `commitlint`.

---

### 🚀 How to Initialize Husky

> Run these from project root:

```bash
# 1. Install Husky
npm install --save-dev husky

# 2. Enable Git hooks
npx husky install

# 3. (Optional but recommended) Auto-install hooks after install
npm pkg set scripts.prepare="husky install"

# 4. Add hooks
npx husky add .husky/pre-commit "npx lint-staged"
npx husky add .husky/pre-push "npm run test"
npx husky add .husky/commit-msg 'npx commitlint --edit "$1"'
```

---

### 📄 Example Hook: `.husky/pre-commit`

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx lint-staged
```

This will run `lint-staged` only on changed files.

---

### 📄 Example Hook: `.husky/pre-push`

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm run test
```

Only push if tests pass.

---

### 📄 Example Hook: `.husky/commit-msg`

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx commitlint --edit "$1"
```

Only accept commits with valid messages (e.g., `feat: add login api`).

---

### ✅ Use Cases

| Hook         | Typical Task                                  |
|--------------|-----------------------------------------------|
| `pre-commit` | Lint, format, test staged files               |
| `pre-push`   | Run test suite, type checks                   |
| `commit-msg` | Enforce Conventional Commits                  |

---
---

## 🐶 Bonus: Husky CLI Setup Tips + Hooks

---

### ✅ Why Use Husky?

Husky makes it easy to run Git hooks like `pre-commit`, `pre-push`, and `commit-msg` to:

- ✅ Auto format/lint staged files
- ✅ Run unit tests
- ✅ Validate commit messages
- ✅ Prevent broken code from being pushed

---

## 🔧 Step-by-Step Husky CLI Setup

### 1. **Install Husky**

```bash
npm install husky --save-dev
```

---

### 2. **Enable Hooks**

```bash
npx husky install
```

> Add to `package.json` so it's auto-set after install:

```json
{
  "scripts": {
    "prepare": "husky install"
  }
}
```

---

### 3. **Add Git Hooks**

#### 📌 Pre-Commit Hook: Lint + Format

```bash
npx husky add .husky/pre-commit "npx lint-staged"
```

**`.husky/pre-commit`**

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx lint-staged
```

---

#### 🚀 Pre-Push Hook: Run Tests

```bash
npx husky add .husky/pre-push "npm run test"
```

**`.husky/pre-push`**

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm run test
```

---

#### ✍️ Commit-msg Hook: Validate Conventional Commits

```bash
npx husky add .husky/commit-msg 'npx --no-install commitlint --edit "$1"'
```

**`.husky/commit-msg`**

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx --no-install commitlint --edit "$1"
```

---

### 🧪 Bonus Tip: Combine Hooks

You can even **chain multiple commands** together, e.g. in `pre-commit`:

```bash
npx lint-staged && npm run type-check && npm test
```

---

### 📁 Resulting Directory Structure

```
.husky/
├── _
│   └── husky.sh                # Auto-generated by husky
├── pre-commit                  # Runs lint-staged
├── pre-push                    # Runs tests
└── commit-msg                  # Validates commit message
```

---

### 🛡️ Benefits

| Hook         | Responsibility                            |
|--------------|--------------------------------------------|
| pre-commit   | Lint, format, check types                 |
| commit-msg   | Ensure good commit message format         |
| pre-push     | Run unit/integration tests before pushing |

---

## 7. 🐙 `.github/` – GitHub Integration (CI/CD + Issues)

### 📁 Tree Structure

```
.github/
├── workflows/
│   └── ci.yml                 # GitHub Actions: CI workflow
└── ISSUE_TEMPLATE/
    ├── bug_report.md         # Template for bug issues
    └── feature_request.md    # Template for feature requests
```

---

### ✅ Purpose

GitHub-specific automation and templates.

- **CI/CD Workflows:** Automate lint/test/build on every push or PR.
- **Issue Templates:** Standardize bug reports and feature requests.

---

### 🚀 How to Use GitHub Actions

1. Create folder:

```bash
mkdir -p .github/workflows
```

2. Add `ci.yml`:

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run lint
      - run: npm run test
```

This CI runs on every PR or commit to `main`.

---

### 📄 Example: `bug_report.md`

```markdown
---
name: 🐞 Bug Report
about: Something isn’t working?
title: '[Bug]: '
labels: bug
---

## Description

A clear and concise description of the issue.

## Steps to Reproduce

1. Go to '...'
2. Click on '....'
3. See error

## Expected behavior

What you expected to happen.

## Screenshots

If applicable, add screenshots.

## Environment

- OS:
- Browser:
- Node.js version:
- App version:
```

---

### ✅ Use Cases

| Folder | Usage |
|--------|-------|
| `.github/workflows/` | Trigger CI/CD workflows using GitHub Actions |
| `.github/ISSUE_TEMPLATE/` | Consistent issue formatting for team/project |

---

## 8. 🐳 `Dockerfile` – Application Containerization

### 📄 Purpose

Defines the steps to **package your NestJS app** into a Docker image.

---

### 📄 Example: `Dockerfile`

```Dockerfile
# Base image
FROM node:18-alpine

# Set working directory
WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci

# Copy source files
COPY . .

# Build the app
RUN npm run build

# Expose API port
EXPOSE 3000

# Run the app
CMD ["node", "dist/main"]
```

---

### ⚙️ How to Build and Run

```bash
# Build the Docker image
docker build -t nestjs-app .

# Run the image
docker run -p 3000:3000 nestjs-app
```

---

### ✅ Use Cases

| Step          | Action                               |
|---------------|--------------------------------------|
| `npm ci`      | Install production-safe dependencies |
| `npm run build` | Compile TypeScript to JS           |
| `CMD`         | Start the app with Node.js           |

---

## 9. 🐳 `docker-compose.yml` – Multi-Service Container Orchestration

### 📄 Purpose

Spin up services like NestJS app, DB, Redis, etc., using **a single command**.

---

### 📄 Example: `docker-compose.yml`

```yaml
version: '3.9'
services:
  app:
    build: .
    ports:
      - '3000:3000'
    volumes:
      - .:/app
    env_file:
      - .env.development
    depends_on:
      - db
      - redis

  db:
    image: postgres:15
    restart: always
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: nestdb
    ports:
      - '5432:5432'
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:alpine
    ports:
      - '6379:6379'

volumes:
  pgdata:
```

---

### ⚙️ How to Use

```bash
# Start all services
docker-compose up --build

# Stop services
docker-compose down
```

---

### ✅ Use Cases

| Service | Role                  |
|---------|-----------------------|
| app     | NestJS application    |
| db      | PostgreSQL container  |
| redis   | Redis for caching     |

---

## 10. ⚙️ `tsconfig.json` – TypeScript Global Config

### 📄 Purpose

Main config file for TypeScript compiler settings.

---

### 📄 Example: `tsconfig.json`

```json
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2021",
    "strict": true,
    "moduleResolution": "node",
    "esModuleInterop": true,
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

---

### Key Fields

| Option           | Purpose                             |
|------------------|-------------------------------------|
| `outDir`         | Output directory after compiling    |
| `baseUrl`        | Base path for resolving imports     |
| `strict`         | Enable all strict type-checking     |
| `sourceMap`      | Needed for debugging (dev only)     |

---

## ⚙️ `tsconfig.build.json` – Build-Specific Override

### 📄 Purpose

Overrides for production builds (usually excludes tests, etc.)

---

### 📄 Example: `tsconfig.build.json`

```json
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "**/*.spec.ts"]
}
```

Used by Nest CLI when you run:

```bash
npm run build
# or
nest build
```

---

### ✅ Use Cases

| File                  | Role                             |
|------------------------|----------------------------------|
| `tsconfig.json`        | Core TS config for dev & IDE     |
| `tsconfig.build.json`  | Clean build config for prod only |

---

## 10. 📏 `.eslintrc.js` – ESLint Config

### 📄 Purpose

Defines **linting rules** to catch bugs, enforce style, and maintain consistency in your codebase.

---

### 📄 Example

```js
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
  },
};
```

---

### ✅ Use Cases

| Feature                    | Benefit                           |
|----------------------------|-----------------------------------|
| Parser + Plugin            | Use with TypeScript               |
| Rule customization         | Fine-tune standards               |
| Prettier integration       | Avoid conflicts with formatting   |

---

### 🔧 Run ESLint

```bash
# Check for lint issues
npx eslint src --ext .ts

# Auto-fix lint errors
npx eslint src --ext .ts --fix
```

---

## 11. 🎨 `.prettierrc` – Code Formatter Config

### 📄 Purpose

Configure **Prettier** to auto-format code consistently across your team.

---

### 📄 Example

```json
{
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all",
  "printWidth": 100,
  "tabWidth": 2
}
```

---

### ✅ Use Cases

| Setting         | Effect                          |
|-----------------|----------------------------------|
| `singleQuote`   | Prefer `'` over `"`             |
| `trailingComma` | Clean Git diffs                 |
| `printWidth`    | Line wrapping for readability   |

---

### 🔧 Format Files

```bash
npx prettier --write src
```

---

## 12. 🧾 `commitlint.config.js` – Enforce Commit Message Convention

### 📄 Purpose

Ensures commit messages follow **conventional format**, enabling automatic changelogs, semantic versioning, etc.

---

### 📄 Example

```js
module.exports = {
  extends: ['@commitlint/config-conventional'],
};
```

---

### ✅ Valid Commit Examples

```bash
git commit -m "feat(user): add user registration"
git commit -m "fix(auth): handle login error"
```

---

### 🚀 Use with Husky

```bash
npx husky add .husky/commit-msg 'npx --no-install commitlint --edit "$1"'
```

---

## 13. 🧼 `lint-staged.config.js` – Lint Only Changed Files

### 📄 Purpose

Used with Husky to run lint, format, or test only **staged files** before commit.

---

### 📄 Example

```js
module.exports = {
  '**/*.ts': ['eslint --fix', 'prettier --write'],
  '**/*.{js,ts,json}': ['prettier --write'],
};
```

---

### ✅ Use Cases

- Prevent bad code from entering commits
- Only targets files you're committing (faster!)

---

### 🛠 Hook Initialization (with Husky)

```bash
# Install Husky if not yet
npm install husky --save-dev
npx husky install

# Add pre-commit hook
npx husky add .husky/pre-commit "npx lint-staged"
```

---

---

### 🔑 **`main.ts`** - The Entry Point of the Application

---

#### Purpose

The **`main.ts`** file is where you initialize the **NestJS application**. It configures global settings such as middleware, global pipes, filters, and interceptors. It’s the main entry point for starting the application.

---

#### Typical **`main.ts`** Structure

Here’s a typical example for a NestJS **`main.ts`**:

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';  // Importing Logger for logging
import { ValidationPipe } from '@nestjs/common';  // To ensure request validation
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';  // Swagger API docs

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Enable global validation
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,   // Only valid properties pass through
    forbidNonWhitelisted: true, // Reject invalid properties
    transform: true,   // Automatically transform DTOs into the correct types
  }));

  // Global middleware
  app.useGlobalInterceptors();

  // Swagger Setup for API Docs
  const config = new DocumentBuilder()
    .setTitle('My API')
    .setDescription('API description')
    .setVersion('1.0')
    .addTag('users')
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);  // The API docs will be available at /api

  // Global logger
  app.useLogger(new Logger());

  await app.listen(3000);  // Define the port for the application to run on
  Logger.log('Application is running on: http://localhost:3000');
}

bootstrap();
```

---

### **Key Points in `main.ts`**

1. **`NestFactory.create(AppModule)`**:
    - This **creates** the NestJS application instance using the root module (`AppModule`).
    - **`AppModule`** is where we import all other modules, including feature modules, and services.
    - You can think of this line as the **"application builder"**.

2. **`useGlobalPipes`**:
    - This sets up **global pipes**, and in the example above, we're using the `ValidationPipe`.
    - The `ValidationPipe` is responsible for validating incoming request bodies and ensuring that data complies with the `DTO` (Data Transfer Object) schema.
    - Options:
        - `whitelist: true`: Strips properties that are not in the DTO class.
        - `forbidNonWhitelisted: true`: Throws an exception if any properties are not part of the DTO.
        - `transform: true`: Transforms plain objects into instances of the DTO classes for type safety.

3. **`useGlobalInterceptors`**:
    - You can add **global interceptors** here, such as logging, transformation of responses, etc.
    - If you have interceptors in the `common/interceptors/` directory, they can be globally used here.

4. **Swagger API Docs**:
    - `DocumentBuilder` helps you configure Swagger for your app (API documentation).
    - You can set a title, description, version, and tags for your API.
    - `SwaggerModule.setup()` will generate an endpoint (`/api` in this case) where you can view the API documentation.

5. **Logging**:
    - We’ve set a custom logger using `Logger`. NestJS has a built-in logger that can be enhanced by creating your own `LoggerService`.
    - Using `app.useLogger()`, we pass the logger that will handle any logs related to request handling, errors, or other information.

6. **Listening on Port**:
    - `await app.listen(3000)` starts the HTTP server and listens on port 3000 (or whatever port you specify in the environment configuration).
    - This is where the application **starts running**.

---

### **How to Use `main.ts` and Customize It**

- **Add Global Middleware**: You can add middleware to the application globally by calling `app.use()` within `main.ts`.
- **Error Handling**: If you have any custom error handling, you can set up **Global Filters** here, just like how we set up pipes and interceptors.
- **Global Guards**: If you want to add authorization checks globally, you can apply global guards using `app.useGlobalGuards()`.

---

### **Example - Custom Global Logger**

If you want to implement a custom logger that integrates with `Winston` or `Pino`, you can replace Nest's default logger with your custom logger by creating a class that extends `LoggerService`.

```typescript
import { LoggerService, Injectable } from '@nestjs/common';
import * as winston from 'winston';

@Injectable()
export class CustomLogger implements LoggerService {
  private logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      transports: [
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple(),
          ),
        }),
      ],
    });
  }

  log(message: string) {
    this.logger.info(message);
  }

  error(message: string, trace: string) {
    this.logger.error(`${message} - Trace: ${trace}`);
  }

  warn(message: string) {
    this.logger.warn(message);
  }
}
```

Then, in `main.ts`, use the custom logger:

```typescript
app.useLogger(new CustomLogger());
```

---

### **Is it Possible to Register Globally?**

Yes, the features in `main.ts` (like pipes, interceptors, filters, and middleware) are registered globally by using the `app.useGlobal...` methods. This ensures that all incoming requests to any controller or module are subject to the same logic.

For example:

- **Pipes** for validation or transformation are global.
- **Interceptors** for logging or response transformation are global.
- **Guards** for authentication/authorization can be globally applied.

You can also use `app.use()` to apply **global middleware**.

---

#### Example of Global Middleware

```typescript
import { Request, Response, NextFunction } from 'express';

function loggerMiddleware(req: Request, res: Response, next: NextFunction) {
  console.log(`Request received at: ${req.url}`);
  next();
}

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.use(loggerMiddleware);  // This will be a global middleware
  await app.listen(3000);
}
```

---

### Conclusion

- **`main.ts`** is the **entry point** of your NestJS app, where global settings and configurations happen.
- You set up **global validation**, **middleware**, **interceptors**, **Swagger API docs**, and **logging** in this file.
- You can **extend and customize** the default configurations to add your own middlewares, loggers, or even use global guards for auth or roles.

---

### 1. **Running Swagger on a Different Port**

By default, the Swagger API docs are served on the same port as the application. However, if you want to serve it on a different port, you can create a **separate HTTP server** specifically for Swagger.

Here’s how you can do that:

#### Solution: Using a Different Port for Swagger

You can create a second HTTP server instance for the Swagger API docs.

Here's how to modify the `main.ts` to run Swagger on a different port:

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import * as express from 'express'; // For creating a separate express server

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Enable global validation
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
  }));

  // Swagger setup for the main app
  const config = new DocumentBuilder()
    .setTitle('My API')
    .setDescription('API description')
    .setVersion('1.0')
    .addTag('users')
    .build();
  const document = SwaggerModule.createDocument(app, config);
  
  // Swagger setup
  SwaggerModule.setup('api', app, document);

  // Create a separate Express server for Swagger on a different port
  const swaggerApp = express();
  swaggerApp.use('/api', SwaggerModule.setup('api', app, document));
  swaggerApp.listen(4000, () => {
    Logger.log('Swagger is running on port 4000');
  });

  // The main app listens on the default port 3000
  await app.listen(3000);
  Logger.log('Application is running on: http://localhost:3000');
}

bootstrap();
```

### Key Notes

- We **create a new express app (`swaggerApp`)** that will serve the Swagger docs.
- We set this **new app to run on port 4000**, while the **NestJS app runs on port 3000**.
- You can change the port numbers (`4000` and `3000`) to whatever you prefer.

---

### 2. **Disabling Swagger in Production Mode**

To disable Swagger in production mode, you can conditionally initialize it based on the **environment**. The **`process.env.NODE_ENV`** variable can help you determine the environment.

Here’s how to **disable Swagger in production**:

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Enable global validation
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
  }));

  // Conditionally enable Swagger based on the environment
  if (process.env.NODE_ENV !== 'production') {
    const config = new DocumentBuilder()
      .setTitle('My API')
      .setDescription('API description')
      .setVersion('1.0')
      .addTag('users')
      .build();
    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup('api', app, document);
  }

  // Listen on default port 3000
  await app.listen(3000);
  Logger.log('Application is running on: http://localhost:3000');
}

bootstrap();
```

### Key Points

- **`process.env.NODE_ENV`** is commonly used to check if the app is running in production or development.
- **In production**, Swagger will not be initialized because the check `if (process.env.NODE_ENV !== 'production')` will fail.
- If you are using other environment management tools (like `.env` files), make sure **`NODE_ENV`** is set correctly. For example, in your `.env.production`, you can set:

    ```
    NODE_ENV=production
    ```

---

### 3. **Summary**

- **Different Port for Swagger**: You can create a separate HTTP server for Swagger and have it run on a different port by using the `express` module alongside NestJS.
- **Disabling Swagger in Production**: You can conditionally disable Swagger in production by checking the `NODE_ENV` environment variable.

---

## 1. **`app.module.ts`** - Root Module of the Application

#### **Purpose**

The `app.module.ts` file is the central module in a NestJS application. It serves as the root module that brings all other modules, services, and controllers together. Essentially, it’s the heart of your application and is responsible for bootstrapping and organizing the app structure.

In this file, you'll:

- Import other modules that the application will use.
- Define global services, controllers, and providers.
- Set up NestJS's dependency injection system.

---

#### **Structure of `app.module.ts`**

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';  // Root controller
import { AppService } from './app.service';        // Root service
import { ConfigModule } from '@nestjs/config';    // Configuration module
import { DatabaseModule } from './infrastructure/database/database.module'; // Database module
import { RedisModule } from './infrastructure/redis/redis.module';         // Redis caching module
import { AuthModule } from './auth/auth.module';   // Authentication module
import { UserModule } from './modules/user/user.module'; // User module

@Module({
  imports: [
    ConfigModule.forRoot(),         // Load environment variables
    DatabaseModule,                 // Register database module
    RedisModule,                    // Register Redis module
    AuthModule,                     // Register Auth module
    UserModule,                     // Register User module
  ],
  controllers: [AppController],    // Root controller to handle requests
  providers: [AppService],         // Root service to handle business logic
})
export class AppModule {}
```

---

#### **Explanation of the Components**

1. **`@Module()` Decorator**:
   - The `@Module()` decorator is used to define a module. Each NestJS module encapsulates a specific feature or functionality of the application (for example, database, user management, authentication, etc.).
   - The decorator accepts the following properties:
     - **`imports`**: An array of other modules that this module needs to use. In our case, it's importing modules like `ConfigModule`, `DatabaseModule`, `AuthModule`, and `UserModule`.
     - **`controllers`**: An array of controllers that are used to handle incoming requests. The controller is responsible for receiving requests, processing them, and returning responses. In this case, `AppController` is used as the root controller.
     - **`providers`**: An array of services or providers that handle the business logic. Here, `AppService` is the root service that provides the business logic for the app.

---

#### **How to Use Modules in `app.module.ts`**

The main reason for using modules in NestJS is to organize your app in a clean, scalable way. Each feature should be encapsulated within its own module, and these modules should then be imported into the root `AppModule`.

For instance:

- **`ConfigModule`**: This module loads environment variables from the `.env` files. It’s used globally in the application to handle configuration.
- **`DatabaseModule`**: Handles all database-related logic (such as connecting to the database, defining entities, and providing database services).
- **`RedisModule`**: Handles Redis-based caching and session management.
- **`AuthModule`**: Handles all authentication logic (JWT, OAuth, etc.).
- **`UserModule`**: Handles user-specific business logic (like user CRUD operations).

These modules are imported into the `AppModule` and registered in the `imports` array to ensure that their services and functionality are available across the entire app.

---

#### **Calling Services or Providers from `app.module.ts`**

The services defined in other modules can be injected into any other service, controller, or module using NestJS's **Dependency Injection (DI)** system.

For example, if you want to inject a service from the **`UserModule`** into the **`AppService`** (defined in `app.service.ts`), you would follow these steps:

1. **In `user.service.ts` (Service in UserModule)**:

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class UserService {
  getUser() {
    return { name: 'John Doe', age: 30 };
  }
}
```

2. **In `app.service.ts` (Root Service)**:

You can inject `UserService` into the `AppService` using NestJS's DI system.

```typescript
import { Injectable } from '@nestjs/common';
import { UserService } from './modules/user/services/user.service';

@Injectable()
export class AppService {
  constructor(private readonly userService: UserService) {}

  getHello(): string {
    const user = this.userService.getUser();
    return `Hello, ${user.name}!`;
  }
}
```

3. **In `app.module.ts` (Root Module)**:

Ensure that `UserService` is available in the `AppModule` by importing `UserModule`:

```typescript
import { UserModule } from './modules/user/user.module';

@Module({
  imports: [UserModule],
  providers: [AppService],
})
export class AppModule {}
```

Now, the `AppService` can access `UserService` and call its methods.

---

#### **Is It Possible to Register Globally?**

Yes! If you want to register a service globally (for example, `UserService`) so that it can be injected into any part of your application, you can make use of **Global Modules**.

Here’s how to create a **global service**:

1. **In `user.module.ts`**:

```typescript
import { Module, Global } from '@nestjs/common';
import { UserService } from './services/user.service';

@Global()  // This decorator makes the module globally available
@Module({
  providers: [UserService],
  exports: [UserService],  // Make the service available to other modules
})
export class UserModule {}
```

2. **In `app.module.ts`**:

Now, `UserService` can be injected anywhere in the app without needing to import `UserModule` explicitly.

---

### **Summary**

- **`AppModule`**: It serves as the root module that imports all other feature modules. It is responsible for bringing the whole app together.
- **Dependency Injection**: Services from other modules are injected into each other via the constructor, providing flexibility and modularity.
- **Global Services**: By using the `@Global()` decorator, you can make a service available across the entire application, eliminating the need for repetitive imports.

---

Certainly! Here's some additional information and best practices on **`app.module.ts`** that you might find useful as you develop your NestJS application:

### 1. **Lazy Loading of Modules**

While we typically import all necessary modules in the `AppModule`, **lazy loading** can be an effective technique in larger applications to load modules only when they are needed. In NestJS, lazy loading is typically applied when using **Dynamic Modules** or **Feature Modules**.

Example:

```typescript
@Module({
  imports: [
    // Feature module that is only loaded when a route is requested
    ProductsModule, 
  ],
})
export class AppModule {}
```

For advanced use cases, you can dynamically load modules using NestJS's `@Module` metadata and `forRootAsync` or `forRoot` methods.

### 2. **Global Providers**

Sometimes you need to create services that are available across multiple modules, without the need to manually import them. This can be done by using **Global Providers**.

In NestJS, **Global Providers** are typically registered in the `AppModule` and can be used throughout the app.

For example, to make a logger service globally available across the entire application, you can do this:

1. **Create a Global Logger Service**:
   - In `logging/logger.service.ts`, define a logger service:

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class LoggerService {
  log(message: string) {
    console.log(message);  // Can be extended to integrate with logging libraries like Winston or Pino
  }
}
```

2. **Register Globally in `app.module.ts`**:
   - Use `@Global()` to make it available globally:

```typescript
import { Global, Module } from '@nestjs/common';
import { LoggerService } from './logging/logger.service';

@Global()  // This makes the logger service globally available
@Module({
  providers: [LoggerService],
  exports: [LoggerService],  // Export it for other modules to use
})
export class LoggerModule {}
```

3. **AppModule**:
   - You can now inject `LoggerService` anywhere in your app without needing to import `LoggerModule` explicitly.

```typescript
import { Module } from '@nestjs/common';
import { LoggerService } from './logging/logger.service';

@Module({
  imports: [],
  providers: [LoggerService],
})
export class AppModule {}
```

Now you can use `LoggerService` anywhere, including controllers, services, or other modules, without explicitly importing the `LoggerModule`.

### 3. **Cross-Cutting Concerns**

In larger applications, certain functionalities are considered "cross-cutting concerns," meaning they need to be applied across the application, such as logging, validation, or caching. These concerns should not be duplicated in multiple places. The solution for these concerns is to create middleware, filters, guards, and interceptors that can be used globally in `AppModule`.

- **Middleware**: Can be used for tasks like logging, request validation, and request transformations.
  - Example: Request logging middleware that logs incoming requests and outgoing responses.
  
- **Guards**: Typically used for authentication/authorization checks. You can use a global guard to apply the same guard to all routes.
  
```typescript
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    // Authentication logic
    return true;
  }
}
```

To make this **global**, you would add it to the `AppModule` like so:

```typescript
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { AuthGuard } from './auth/auth.guard';

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
  ],
})
export class AppModule {}
```

This ensures that the `AuthGuard` is used for all routes in the application unless explicitly overridden.

- **Interceptors**: Interceptors can be applied globally to modify the response or handle error scenarios.
  - Example: You could use an interceptor to transform all responses into a standard format.

```typescript
import { Injectable } from '@nestjs/common';
import { CallHandler, ExecutionContext, NestInterceptor } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class ResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map(data => ({
        status: 'success',
        data,
      })),
    );
  }
}
```

To apply this **globally**, you can register it in the `AppModule`:

```typescript
import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { ResponseInterceptor } from './common/interceptors/response.interceptor';

@Module({
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: ResponseInterceptor,
    },
  ],
})
export class AppModule {}
```

### 4. **Asynchronous Providers**

Some services may require asynchronous configuration or initialization, such as connecting to a database or external API. NestJS allows you to create **asynchronous providers**.

Example for asynchronous configuration with `ConfigModule`:

```typescript
@Module({
  imports: [
    ConfigModule.forRoot({
      load: [configuration],  // loads the async configuration
      isGlobal: true,         // make it globally available
    }),
  ],
})
export class AppModule {}
```

This ensures that the configuration is available globally across all modules.

### 5. **Custom Error Handling**

In larger applications, it’s important to have custom error handling strategies, such as sending specific HTTP status codes, error messages, or using structured logging. You can achieve this with NestJS’s **Exception Filters**.

For example, create a custom exception filter to handle `HttpException`:

```typescript
import { ExceptionFilter, Catch, ArgumentsHost } from '@nestjs/common';
import { HttpException } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();
    const status = exception.getStatus();
    const message = exception.message;

    response.status(status).json({
      statusCode: status,
      message,
    });
  }
}
```

To register it globally:

```typescript
import { Module } from '@nestjs/common';
import { APP_FILTER } from '@nestjs/core';
import { HttpExceptionFilter } from './common/filters/http-exception.filter';

@Module({
  providers: [
    {
      provide: APP_FILTER,
      useClass: HttpExceptionFilter,
    },
  ],
})
export class AppModule {}
```

---

### **Summary**

- **AppModule** is the root module and serves as the central hub for importing and organizing all other modules.
- **Global Providers**, **Guards**, **Middleware**, and **Interceptors** can be applied globally to handle cross-cutting concerns.
- You can make certain services or modules available globally via the `@Global()` decorator.
- **Asynchronous Providers** are useful for services that need to be initialized or configured asynchronously.
- Custom error handling can be implemented using **Exception Filters**.

These strategies can make  NestJS application more maintainable, scalable, and easier to debug
---

### for **config/** directory structure go to *2. src_config-directory-structure.md*
