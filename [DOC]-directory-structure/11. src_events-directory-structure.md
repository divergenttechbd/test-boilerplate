Awesome! Let's move on to the next directory:  
<br>

---

# ğŸ“£ `events/` â€“ Application-Level Event Emitters & Listeners

---

## âœ… **Purpose**

The `events/` directory manages **application-level events** using **NestJS's `EventEmitterModule`**. This pattern is part of the **event-driven architecture**, allowing you to decouple business logic and enable **modular, asynchronous communication** across your system.

---

## ğŸ“ Recommended Directory Structure

```ts
ğŸ“£ events/                          # Application-wide event system
â”œâ”€â”€ ğŸ“„ events.module.ts            # EventEmitter setup and global registration
â”œâ”€â”€ ğŸ“ emitters/                   # Emitters for triggering events
â”‚   â””â”€â”€ ğŸ“„ user-events.emitter.ts  # Example: Emit user-related events
â”œâ”€â”€ ğŸ“ listeners/                  # Handlers that react to events
â”‚   â”œâ”€â”€ ğŸ“„ user-events.listener.ts # Example: Send email, log audit, etc.
â”‚   â””â”€â”€ ğŸ“„ auth-events.listener.ts # Handle login/logout events
â””â”€â”€ ğŸ“ types/                      # Define shared types/interfaces for events
    â””â”€â”€ ğŸ“„ event-payloads.interface.ts
```

---

## ğŸ§± 1. `events.module.ts` â€“ Global Event Emitter Setup

```ts
import { Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { UserEventsEmitter } from './emitters/user-events.emitter';
import { UserEventsListener } from './listeners/user-events.listener';
import { AuthEventsListener } from './listeners/auth-events.listener';

@Module({
  imports: [EventEmitterModule.forRoot()],
  providers: [
    UserEventsEmitter,
    UserEventsListener,
    AuthEventsListener,
  ],
  exports: [UserEventsEmitter],
})
export class EventsModule {}
```

> ğŸ”¹ The `EventEmitterModule` makes the event system available throughout the app.

---

## ğŸ“¤ 2. `emitters/user-events.emitter.ts` â€“ Emit User Events

```ts
import { Injectable } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { UserCreatedPayload } from '../types/event-payloads.interface';

@Injectable()
export class UserEventsEmitter {
  constructor(private eventEmitter: EventEmitter2) {}

  emitUserCreatedEvent(payload: UserCreatedPayload) {
    this.eventEmitter.emit('user.created', payload);
  }

  emitUserUpdatedEvent(payload: UserCreatedPayload) {
    this.eventEmitter.emit('user.updated', payload);
  }
}
```

> ğŸ”¹ This service can be injected into any module and used to fire custom events.

---

## ğŸ§ 3. `listeners/user-events.listener.ts` â€“ Handle User Events

```ts
import { OnEvent } from '@nestjs/event-emitter';
import { Injectable } from '@nestjs/common';
import { UserCreatedPayload } from '../types/event-payloads.interface';

@Injectable()
export class UserEventsListener {
  @OnEvent('user.created', { async: true })
  async handleUserCreated(payload: UserCreatedPayload) {
    console.log(`[Event] User created:`, payload);
    // e.g. send email, log to audit, trigger workflow
  }

  @OnEvent('user.updated')
  handleUserUpdated(payload: UserCreatedPayload) {
    console.log(`[Event] User updated:`, payload);
  }
}
```

> ğŸ”¹ Listeners are automatically triggered when events are emitted.

---

## ğŸ” 4. `listeners/auth-events.listener.ts` â€“ Handle Auth Events

```ts
@Injectable()
export class AuthEventsListener {
  @OnEvent('auth.login')
  handleLogin(data: { userId: string; time: string }) {
    console.log(`[Event] User logged in:`, data);
  }

  @OnEvent('auth.logout')
  handleLogout(data: { userId: string }) {
    console.log(`[Event] User logged out:`, data);
  }
}
```

> ğŸ”¹ Use for logging login activity, token refresh, security alerts.

---

## ğŸ§¾ 5. `types/event-payloads.interface.ts` â€“ Shared Event Types

```ts
export interface UserCreatedPayload {
  id: string;
  name: string;
  email: string;
  timestamp: Date;
}
```

> ğŸ”¹ Strong typing for payloads improves DX and prevents runtime errors.

---

## âš™ï¸ How to Use in Other Modules

### â• Step 1: Inject the Emitter

```ts
constructor(private readonly userEventsEmitter: UserEventsEmitter) {}
```

### â• Step 2: Emit the Event

```ts
await this.userEventsEmitter.emitUserCreatedEvent({
  id: user.id,
  name: user.name,
  email: user.email,
  timestamp: new Date(),
});
```

---

## ğŸ’¡ Use Cases (Real World)

| Event Name       | Emitter Location     | Listener Action                                      |
|------------------|----------------------|------------------------------------------------------|
| `user.created`   | UserService           | Send email, log audit, create welcome task           |
| `auth.login`     | AuthService           | Log IP, notify user, record in audit trail           |
| `invoice.paid`   | PaymentService        | Email invoice, notify accounting                     |
| `file.uploaded`  | FileUploadService     | Trigger virus scan, move to S3                       |
| `user.deleted`   | AdminService          | Delete from mailing list, revoke access              |

---

## ğŸ“‹ Summary

| Feature                          | Available? |
|----------------------------------|------------|
| Strong-typed payloads            | âœ…         |
| Global accessibility             | âœ…         |
| Async event handling             | âœ…         |
| Multiple listeners per event     | âœ…         |
| Scoped / modular registration    | âœ…         |
| Integration with jobs/queue      | âœ…         |

---

Will share detail description on:

1. A test case for emitter & listener.
2. Event-to-Queue pattern (emit event, enqueue job)

---

Awesome! You're thinking in the right directionâ€”event emitters paired with listeners and background jobs via queue create a **powerful, decoupled**, and **scalable architecture**.  
Letâ€™s break this down in two major parts as you asked:

---

# âœ… 1. Test Case for `EventEmitter` and Listener

## ğŸ§ª Use Case

**Scenario**: When a new user is registered, an event `user.created` is emitted. The listener should:

- Log the event
- Simulate sending a welcome email (as a mock)

---

### ğŸ“ Directory: `events/emitters/user-events.emitter.spec.ts`

```ts
import { Test, TestingModule } from '@nestjs/testing';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { UserEventsEmitter } from './user-events.emitter';

describe('UserEventsEmitter', () => {
  let emitterService: UserEventsEmitter;
  let eventEmitter: EventEmitter2;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UserEventsEmitter, EventEmitter2],
    }).compile();

    emitterService = module.get<UserEventsEmitter>(UserEventsEmitter);
    eventEmitter = module.get<EventEmitter2>(EventEmitter2);

    jest.spyOn(eventEmitter, 'emit');
  });

  it('should emit a user.created event', () => {
    const payload = {
      id: 'u123',
      name: 'John Doe',
      email: 'john@example.com',
      timestamp: new Date(),
    };

    emitterService.emitUserCreatedEvent(payload);

    expect(eventEmitter.emit).toHaveBeenCalledWith('user.created', payload);
  });
});
```

---

### âœ… What This Test Does

- Mocks the `EventEmitter2`
- Spies on `emit()`
- Confirms that `emitUserCreatedEvent()` calls it with correct event name and payload

---

# ğŸ” 2. Event â†’ Queue Pattern

## âœ… Real-World Use Case

Letâ€™s say when `user.created` is emitted:

- Listener handles the event
- It pushes a job to the queue for **sending welcome email**

---

## ğŸ§© Directory Structure

```bash
ğŸ“ events/
â”‚   â”œâ”€â”€ emitters/user-events.emitter.ts
â”‚   â””â”€â”€ listeners/user-events.listener.ts
ğŸ“ jobs/
â”‚   â””â”€â”€ processors/send-email.processor.ts
ğŸ“ queue/
â”‚   â”œâ”€â”€ queue.module.ts
â”‚   â”œâ”€â”€ bull-config.service.ts
â”‚   â””â”€â”€ queue.constants.ts
```

---

## ğŸ§± Step-by-Step Implementation

---

### ğŸ” `queue/queue.constants.ts`

```ts
export const QUEUE_NAMES = {
  EMAIL: 'email_queue',
};
```

---

### âš™ï¸ `queue/bull-config.service.ts`

```ts
import { Injectable } from '@nestjs/common';
import { BullOptionsFactory, BullModuleOptions } from '@nestjs/bull';

@Injectable()
export class BullConfigService implements BullOptionsFactory {
  createBullOptions(): BullModuleOptions {
    return {
      redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: +process.env.REDIS_PORT || 6379,
      },
    };
  }
}
```

---

### ğŸ§© `queue/queue.module.ts`

```ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { BullConfigService } from './bull-config.service';
import { QUEUE_NAMES } from './queue.constants';
import { SendEmailProcessor } from '../../jobs/processors/send-email.processor';

@Module({
  imports: [
    BullModule.forRootAsync({ useClass: BullConfigService }),
    BullModule.registerQueue({ name: QUEUE_NAMES.EMAIL }),
  ],
  providers: [SendEmailProcessor],
  exports: [],
})
export class QueueModule {}
```

---

### ğŸ“¤ `events/listeners/user-events.listener.ts`

```ts
import { OnEvent } from '@nestjs/event-emitter';
import { Injectable } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { QUEUE_NAMES } from '../../queue/queue.constants';
import { UserCreatedPayload } from '../types/event-payloads.interface';

@Injectable()
export class UserEventsListener {
  constructor(
    @InjectQueue(QUEUE_NAMES.EMAIL) private readonly emailQueue: Queue,
  ) {}

  @OnEvent('user.created')
  async handleUserCreated(payload: UserCreatedPayload) {
    console.log('Event received, enqueueing welcome email job...');

    await this.emailQueue.add('sendWelcomeEmail', {
      userId: payload.id,
      email: payload.email,
      name: payload.name,
    });
  }
}
```

---

### ğŸ§µ `jobs/processors/send-email.processor.ts`

```ts
import { Process, Processor } from '@nestjs/bull';
import { Job } from 'bull';
import { QUEUE_NAMES } from '../../queue/queue.constants';

@Processor(QUEUE_NAMES.EMAIL)
export class SendEmailProcessor {
  @Process('sendWelcomeEmail')
  async handleSendWelcomeEmail(job: Job) {
    const { userId, email, name } = job.data;

    console.log(`[Processor] Sending welcome email to ${name} <${email}>`);

    // Simulate email sending logic (real one uses nodemailer, Mailgun, etc.)
    await new Promise((resolve) => setTimeout(resolve, 1000));

    console.log(`[Processor] Email sent to ${email}`);
  }
}
```

---

## ğŸ§  How to Use From Other Modules?

### ğŸ” Emit Event From Anywhere

Inject the emitter and emit the event:

```ts
constructor(private readonly userEventsEmitter: UserEventsEmitter) {}

await this.userEventsEmitter.emitUserCreatedEvent({
  id: user.id,
  name: user.name,
  email: user.email,
  timestamp: new Date(),
});
```

ğŸ¯ This triggers:

1. `user.created` â†’
2. `UserEventsListener` reacts â†’
3. Pushes job to queue â†’
4. `SendEmailProcessor` handles it asynchronously.

---

## ğŸ” Benefits of This Pattern

| Benefit                       | Explanation |
|------------------------------|-------------|
| âœ… Decouples logic            | Events donâ€™t know who will handle them. Scales cleanly. |
| âœ… Background processing      | Offloads slow tasks (email, image resize, reports). |
| âœ… Auto-retries & monitoring  | Bull queue supports retries, backoff, dead-lettering. |
| âœ… Graceful failure handling  | Even if event fails, your main logic is unaffected. |
| âœ… Plug & play jobs           | Easy to attach more jobs to same events later. |

---

Possible Implementatiion:

- Retry & backoff strategy for failed jobs?
- Event-to-multiple-queues example?
- Monitoring queues via Bull Board?
